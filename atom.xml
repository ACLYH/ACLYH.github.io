<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ACLYH.github.io</id>
    <title>Lanthanum</title>
    <updated>2021-09-20T13:46:16.209Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ACLYH.github.io"/>
    <link rel="self" href="https://ACLYH.github.io/atom.xml"/>
    <subtitle>心之所向，素履以往，生如逆旅，一苇以航。</subtitle>
    <logo>https://ACLYH.github.io/images/avatar.png</logo>
    <icon>https://ACLYH.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Lanthanum</rights>
    <entry>
        <title type="html"><![CDATA[夜里]]></title>
        <id>https://ACLYH.github.io/post/ye-li/</id>
        <link href="https://ACLYH.github.io/post/ye-li/">
        </link>
        <updated>2021-09-20T13:28:24.000Z</updated>
        <summary type="html"><![CDATA[<p>12：25</p>
<p>夜已深。</p>
<p>看着窗外，昏黄的灯火，零星的几户未眠人家，不知停歇的红绿灯，在这万籁俱寂的夜里明明灭灭。</p>
<p>稀疏，寂静的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>12：25</p>
<p>夜已深。</p>
<p>看着窗外，昏黄的灯火，零星的几户未眠人家，不知停歇的红绿灯，在这万籁俱寂的夜里明明灭灭。</p>
<p>稀疏，寂静的。</p>
<!-- more -->
<p>浅浅的光在黑夜里挣扎着，不让昏暗吞噬那一抹渺小却温暖的灯火。</p>
<p>风在窗外轻盈的舞动，拂过窗棂，顺着留下的浅浅缝隙灌进来，吹着窗帘，宛如鼓动的，洁白的衣袍。</p>
<p>夜空并不是真正的黑色，而是莫名的昏黄，像画中的褐黄，调了淡淡的黑。是人间的倒映，将天光染上了昏黄的灯火。</p>
<p>这段时间，仿佛是消失踪迹一般，昔日道路上的人影随风而散，亮如白昼的霓虹灯被夜色淡然掩盖，平日默默奔忙的公交车失了行迹，只剩下冬日落光了叶子的银杏在春夜慢慢发芽，似乎夜的风都带了淡淡的一丝清新。空旷而寂寥的夜里，失了往日的烟火，少了大街小巷的喧嚣，只剩下空茫的风顺着无一人的街道淡淡划过。留下寒冷的痕迹，映在同样冰冷的窗玻璃上。</p>
<p>12:40。</p>
<p>本就零星的灯火愈发稀疏，像天空的星辰被云雾遮住了光，匿在了茫茫黑夜。像一根灯心燃尽了蜡油，掐断了烛焰。像一缕发丝终于承受不起载着的千斤，猛然的断了。泼洒的墨水在一栋栋大楼上晕染开来，稀疏的光点如同渔舟驶进汹涌的海里，摇晃着，坠在浪里，落在夜里,溅起墨色的痕迹。</p>
<p>1：10。</p>
<p>灯影缥缈，树未眠。</p>
<p>高楼里燃尽了灯火，只剩下黑梭梭的影子矗立在苍茫的夜里。露出隐隐约约轮廓，仿佛无声的雕塑，空洞的俯视着立足之地。但，那些昏黄的路灯依然散着飘渺不定的光。树影婆娑，在风中簇拥成浪，地面的光斑也跟着飘荡着，像河川上行着的渔舟，摇摇晃晃却永远亮着。驶过春风秋雨，夏月冬日。</p>
<p>明明灭灭的光，立在路边，勾勒出一条在夜里看起来遥不可及亦真亦幻的路。怀着温暖的橘黄色，像希望。</p>
<p>1：30。</p>
<p>夜色彻底沉了下来，不似之前的昏黄，变得浓稠起来。没有星星，只剩下一望无际的黑，延续到天边，在天际与地平线化作一体，搅合着高楼的影子，浓的得再也化不开。只剩下那稀疏的路灯光汇聚成的路，浅浅的，却在这夜色里足以看得清，将天际与大地分出微微的不同。像雾中的指引，像混沌中的清明，像人间独有的烟火气。</p>
<p>不知道什么时候，渐渐对黑夜萌生出了一丝好感。或是因为黑夜的宁静，或是黑夜包容了一切丑恶与不堪，或是它让白天忙碌的人们拥有了静下来的时光，亦或是，它收集起了灯火，收集起了光。光是常见的，亦是在白天随处可至的 。它们同太阳降临人间，给予万物于生机，拂去朦胧的水汽，带来人间以悲欢。它们随太阳而生，在黎明时给这一端带了灿烂与辉煌，又在日暮时放尽残阳的光辉。而夜，将这光小心的收集起来，凝聚成星空，倒映成人间烟火。白天随处可见的光，却成了黑夜的珍宝，在茫茫夜空中那么清晰。是白日里尚未消失殆尽的余光，是坚持在夜里留守的使者，它给予夜色，留下温暖的痕迹。</p>
<p>星星的光从遥远的太空而来，离我们有多少光年，来到我们眼前，就要多少年。它们是远古而来的光，跨过了时空的桎梏，从千万年前奔来与我们相会。</p>
<p>就像一条连接时空的纽带，从过去，到现在，去将来。</p>
<p>我忽然想起，西方普罗米修斯为人类留下的火种，中国古代那些人们拼尽全力留下的薪火，远古人类冒着生命危险去雷击之地取来的天火。</p>
<p>于他们而言，仿佛只是能带来温暖，带来光明，驱走黑夜与饥渴的野兽。</p>
<p>然而，他们留下的火种，却燃烧起了人类长久的文明，不熄的光。</p>
<p>1：50</p>
<p>记起小时候，晚上玩耍回家迟了，而走在楼下，一抬头终总会看到一抹未熄的灯光在等着我。</p>
<p>小时候怕黑，不愿关上卧室的门，注视着客厅溜出来的光，渐渐沉入梦乡。或者有时候打了雷，外公总在窗外雷声乍起时踏进来，陪着我，让我不要怕，让我可以看到他眼镜片的反光。</p>
<p>或者以前过年，爸爸妈妈带来一捆烟火，让我看着一抹流光绚丽的火花绽放。</p>
<p>夏日在一荷花池中钓虾，看着饵落入水中荡开涟漪，又在拉上一只虾时溅起水花。荷花盛开，清风送香，水光潋滟，葳蕤生光。</p>
<p>那年去上海参赛，一日空闲，随同学老师走走上海滩。那日下着细雨，撑起一把把伞，在黄埔江边看东方明珠塔。但雨云却遮了一大半，看不真切，略干感失望。然而晚上，我们却都收到老师发来的一张照片。躺在床上，突然翻到一张东方明珠塔的夜景。带着霓虹，在黑沉沉的夜里那样璀璨，像模糊而又微微清晰的未来，很美。她一个人在晚上来的江边，留下了这张照片，也留下了烙印在我们心中的印记。像华光璀璨的东方明珠塔，是霓虹的颜色。</p>
<p>那个暑假在海南的一座小岛。那天有些不幸，刮了大风，停了电。一行人拿着蜡烛，坐在天台上，闲聊。那日有月亮，有漫入眼睛的星星。遥不可及，却又那样真实，仿佛垂手可得。从那里可以隐隐约约的看到海，耳边听着微小的海浪声，吹着天台上吹来的风，看着蜡烛的火摇曳着燃烧。旅人谈论着过几天要去哪里，或是亲人们闲聊着家常。那些旅人对我们来说只不过是萍水相逢，却依然东扯一句，西来一句的交谈着。明明是不久就要分别的人们，却让我多希望时光能停下来，留存在那一刻。星星似乎离我们好远，像时光，是暖暖的，却又无法阻拦他运行的轨迹，只能默默看着它画出永恒的图谱。</p>
<p>也有不久前在泰国的一座小岛上，入夜，仰望天空，满天繁星沉沉入目。很久没有看见过如此之多的星辰了。记忆还是在儿时，仲夏故乡的院坝里，坐在躺椅里，沉甸甸的摇晃着蒲扇，听着虫鸣与老人絮絮叨叨的古老故事相呼应。抬头便是辽阔的夜空，微微泛紫，嵌着数不清的星辰。</p>
<p>那些在黑夜里微微发亮的光，在记忆里构成了一条宽广的河，仿佛苍穹携着银河，那些关于光的记忆，便在星空的波涛里沉沉浮浮。</p>
<p>2：20。</p>
<!-- more -->
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020CSP-S]]></title>
        <id>https://ACLYH.github.io/post/2020csp-s/</id>
        <link href="https://ACLYH.github.io/post/2020csp-s/">
        </link>
        <updated>2020-11-04T10:36:27.000Z</updated>
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1368398851&auto=1&height=66"></iframe>
<h4 id="2020-11-04">2020-11-04</h4>
<p>还有3天CSP-S，AFO。<br>
<s>这边准备好AFO了</s></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[10-31爆零记]]></title>
        <id>https://ACLYH.github.io/post/10-31-bao-ling-ji/</id>
        <link href="https://ACLYH.github.io/post/10-31-bao-ling-ji/">
        </link>
        <updated>2020-11-01T08:29:46.000Z</updated>
        <content type="html"><![CDATA[<p><s>11月7日提高组，我怎么觉得我要炸呢</s></p>
<h4 id="t1互不攻击的炮">T1:互不攻击的炮</h4>
<p>(canon.cpp/in/out 1s 128M)<br>
在一个 N 行 M 列的棋盘上，让你放若干个炮（可以是 0 个），使得没有一个炮可以攻击到<br>
另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个<br>
炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。你也<br>
来和小可可一起锻炼一下思维吧！<br>
输入<br>
一行包含两个整数 N，M，之间由一个空格隔开。 N 和 M 均不超过 6<br>
输出<br>
总共的方案数，由于该值可能很大，只需给出方案数模 9999973 的结果。<br>
样例</p>
<pre><code>输入
1 3
输出
7
</code></pre>
<p>提示<br>
除了 3 个格子里都塞满了炮以外，其它方案都是可行的，所以一共有 2<em>2</em>2-1=7 种方案。</p>
<p>简单的DFS，由题可知，每一行和每一列的棋子个数都不会超过2个，一个一个格子判断。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
int sx[1010000],sy[1010000];
int ans = 0;
void dfs(int x,int y){
	if(x==n+1&amp;&amp;y==1){
		ans++;
//		ans%=9999973;
		return ;
	}
	if(sx[x]&lt;2&amp;&amp;sy[y]&lt;2){
		sx[x]++;
		sy[y]++;
		if(y==m)dfs(x+1,1);
		else dfs(x,y+1);
		sx[x]--;
		sy[y]--;
		if(y==m){
			dfs(x+1,1);
		}else{
			dfs(x,y+1);
		}
	}else{
		if(y==m){
			dfs(x+1,1);
		}else{
			dfs(x,y+1);
		}
	}
	
}
int main(){
	cin &gt;&gt; n &gt;&gt;m;
	dfs(1,1);
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<p>T2 Photography</p>
<p>农夫 John（以后简称“FJ”）的 N 头奶牛站在一个一维长篱笆上的不同位置 (1 &lt;= N &lt;=<br>
100,000)。第 i 头奶牛站在位置 x_i (一个处于范围 0...1,000,000,000 的整数)，其品种为 b_i<br>
（要么为‘G’，表示根西种 Guernsey，要么为‘H’，表示霍斯坦种 Holstein）。每头奶牛的位置<br>
各不相同。FJ 想要为一段连续区间内的奶牛拍张照片，用来参加郡里的展览会，但是他想让<br>
照片里各个品种奶牛的数量是“公平的”。所以，他想要使得无论照片里出现了多少个品种的<br>
奶牛，这些品种奶牛的数量必须相同（例如，一张照片里可以全是霍斯坦种奶牛，也可以出<br>
现 27 头根西种奶牛和 27 头霍斯坦种奶牛，但不能出现 10 头霍斯坦种奶牛和 9 头根西种奶<br>
牛，这种情况下各个品种数量不同）。帮助 FJ 拍一张满足其要求的最大尺寸照片。一张照片<br>
的尺寸为照片中最左边的奶牛和最右边的奶牛的位置差。可能 FJ 拍出的照片里只有一头奶<br>
牛，此时照片的尺寸为 0。<br>
输入<br>
第 1 行：整数 N。<br>
第 2..1+N 行：第 i+1 行包含 x_i 和 b_i。<br>
输出<br>
第 1 行：一个整数，表示一张“公平的”照片的最大尺寸。</p>
<pre><code>样例输入
6
4 G
10 H
7 G
16 G
1 G
3 H
【输入说明】
有 6 头奶牛（从左到右）品种分别为 G, H, G, G, H, G。
样例输出
7
【输出说明】
FJ 可以拍出的最大尺寸“公平的”照片是出现中间 4 头奶牛的照片，包括了 2 头霍斯坦种奶牛
和 2 头根西种奶牛。
</code></pre>
<p>前缀和。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=1e5+10;
int n;
int exnn[maxn];
struct cow{
	int x,op;
}a[maxn];

bool cmp(const cow &amp;a,const cow &amp;b){
	return a.x&lt;b.x;
}
bool check(int x){
	int r=0;
	for(int l=1;l&lt;=n;l++) {				
		while(a[r].x-a[l].x&lt;x&amp;&amp;r&lt;n)r++;
		if(a[r].x-a[l].x&lt;x)break;		
		if(exnn[r]-exnn[l-1]&gt;=0&amp;&amp;(exnn[r]-exnn[l-1])%2==0){
			return true;
		}
	}
	return 0;
}
int main(){
	cin &gt;&gt; n;
	for(int i=1;i&lt;=n;i++){
		char op[2];
		cin &gt;&gt; a[i].x&gt;&gt;op;
		if(op[0]=='H')a[i].op=1;
		else a[i].op=-1;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i&lt;=n;i++){
		exnn[i]=exnn[i-1]+a[i].op;
	}
	int lb=0,ub=0x3f3f3f3f;
	while(ub-lb&gt;1){
		int mid=(lb+ub)&gt;&gt;1;
		if(check(mid))lb=mid;
		else ub=mid;
	}
	cout&lt;&lt;lb&lt;&lt;endl;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最小生成树模板]]></title>
        <id>https://ACLYH.github.io/post/zui-xiao-sheng-cheng-shu-mo-ban/</id>
        <link href="https://ACLYH.github.io/post/zui-xiao-sheng-cheng-shu-mo-ban/">
        </link>
        <updated>2020-10-28T13:39:00.000Z</updated>
        <summary type="html"><![CDATA[<p>题目描述</p>
<p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目描述</p>
<p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz</p>
<!-- more -->
<p>输入输出格式<br>
输入格式：</p>
<p>第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000）</p>
<p>接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi</p>
<p>输出格式：</p>
<p>输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz</p>
<p>输入输出样例<br>
输入样例#1：</p>
<p>4 5<br>
1 2 2<br>
1 3 2<br>
1 4 3<br>
2 3 4<br>
3 4 3</p>
<p>输出样例#1：</p>
<p>7</p>
<p>数据规模：</p>
<p>对于20%的数据：N&lt;=5，M&lt;=20</p>
<p>对于40%的数据：N&lt;=50，M&lt;=2500</p>
<p>对于70%的数据：N&lt;=500，M&lt;=10000</p>
<p>对于100%的数据：N&lt;=5000，M&lt;=200000</p>
<p>样例解释：<br>
<img src="https://img-blog.csdnimg.cn/20190609135251535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
所以最小生成树的总边权为2+2+3=7</p>
<p>并查集<br>
既然最小，那么重载cmp函数。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
struct node{
    int u;
    int w;
    int v;
}g[1110000];
bool cmp(node a,node b){
    return a.w&lt;b.w;
}
int fa[10010];
void init(){
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
}
int get(int x){
    if(fa[x]==x){
        return x;
    }else{
        int y=get(fa[x]);
        fa[x]=y;
        return y;
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].w;
    }
    init();
    sort(g+1,g+1+m,cmp);
    int ans=0;
    for(int i=1;i&lt;=m;i++){
        if(get(g[i].u)!=get(g[i].v)){
            ans+=g[i].w;
            fa[get(g[i].u)]=get(g[i].v);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路（单源）]]></title>
        <id>https://ACLYH.github.io/post/zui-duan-lu-dan-yuan/</id>
        <link href="https://ACLYH.github.io/post/zui-duan-lu-dan-yuan/">
        </link>
        <updated>2020-10-28T13:36:36.000Z</updated>
        <summary type="html"><![CDATA[<p>Dijkstra算法和SPFA算法用于求单源最短路。<br>
最短路就是求两点之间的最短路径。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Dijkstra算法和SPFA算法用于求单源最短路。<br>
最短路就是求两点之间的最短路径。</p>
<!-- more -->
<p>最短路径怎么求呢？<br>
更新就是了（松弛）。<br>
<img src="https://img-blog.csdnimg.cn/20190419201104445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">先赋予厚望（先假设无穷大）<br>
<img src="https://img-blog.csdnimg.cn/20190419201303886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">然后依次更新<br>
<img src="https://img-blog.csdnimg.cn/20190419202104933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
通过起点1来比较哪条路到终点20最短</p>
<p><img src="https://img-blog.csdnimg.cn/20190419202225404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">暂时选择这条绿色的路<br>
继续比较<br>
<img src="https://img-blog.csdnimg.cn/20190419202710202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
所以蓝色的路是最短的。<br>
然后看一道纯模板题。</p>
<pre><code>骑车比赛

Description

小信准备去参加骑车比赛，比赛在 n 个城市间进行，编号从 1 到 n。选手们都从城市 1 出发，终点在城市 n。

已知城市间有 m 条道路，每条道路连接两个城市，注意道路是双向的。现在小信知道了他经过每条道路需要花费的时间，他想请你帮他计算一下，他这次比赛最少需要花多少时间完成。

Input

第一行输入两个整数 n,m（1≤n≤1,000,1≤m≤5,000），分别代表城市个数和道路总数。接下来输入 m 行，每行输入三个数字 a,b,c（1≤a,b≤n,1≤c≤200），分别代表道路的起点和道路的终点，以及小信骑车通过这条道路需要花费的时间。保证输入的图是连通的。

Output

输出一行，输出一个整数，输出小信完成比赛需要的最少时间。

Sample Input 1

5 6
1 2 2
2 3 3
2 5 5
3 4 2
3 5 1
4 5 1

Sample Output 1

6


</code></pre>
<p>典型的最短路<br>
Dijkstra模板：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;


int n,m;

struct node{//结构体
	int v,w;
	node(){ };
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
int dst[10100];

void add(int u,int v,int w){//建图
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){
	memset(dst,0x3f,sizeof dst);
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			int w = g[u][j].w;
			dst[v] = min(dst[v],dst[u]+w);
			
		}
		
		int mi=0x3f3f3f3f;//无穷大
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v,w;
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	
	dij(1);
	cout &lt;&lt; dst[n];
	
	return 0;
}
</code></pre>
<p>SPFA模板</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=1010;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
int inq[maxn];

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}

void spfa(int s){
	memset(dst,inf,sizeof dst);
	int u=s;
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	int u , v , w; 
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	spfa(1);
	cout &lt;&lt; dst[n]&lt;&lt;endl;
	return 0;
}
</code></pre>
<pre><code>迷阵突围

Description

小信陷入了坐标系上的一个迷阵，迷阵上有 n个点，编号从 1 到 n。小信在编号为 1 的位置，他想到编号为 n 的位置上。小信当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在小信知道了 n 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

注意，每条路径上不能重复经过同一个点。

Input

第一行输入两个整数 n (1≤n≤200) 和 m，表示一共有 n 个点和 m 条边。

接下来输入 n 行，每行输入两个整数 xi,yi (−500≤xi,yi≤500)，代表第 i 个点的坐标。

接下来输入 m 行，每行输入两个整数 pj,qj (1≤pj,qj≤n)，表示点 pj 和点 qj 之间相连。

Output

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 -1。

Sample Input 1

3 3
1 1
2 2
3 2
1 2
2 3
1 3

Sample Output 1

2.41


</code></pre>
<p>模板改进。（两个dij函数）</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,m;

struct node{
	int v;
	double w;
	node(){ };
	node(int _v,double _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
double dst[10100];

int x[10100],y[10100];
int pre[10100];
void add(int u,int v,double w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){

	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				pre[v]=u;
			}
		}
		
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}

}


void dij2(int s,int uu,int vv){
	
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(uu ==u &amp;&amp; vv==v || uu==v &amp;&amp; vv == u){
				continue;
			}
	
			dst[v] = min(dst[v],dst[u]+w);

	}
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	 
	}

}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v;
	double w;
	
	for(int i=1;i&lt;=n;i++){
		cin &gt;&gt; x[i] &gt;&gt;y[i];
	}
	
	while (m--){
		cin &gt;&gt; u &gt;&gt; v;
		w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
		add(u,v,w);
	}
	
	dij(1);

	
	double mi=1e20;
	for(int i=n;pre[i]!=0;i=pre[i]){
		dij2(1,i,pre[i]);
		mi=min(mi,dst[n]);
	}
	     if(mi == 1e20){
	      cout &lt;&lt; &quot;-1&quot;&lt;&lt;endl;
		 }else{
			 cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mi&lt;&lt;endl;
		}
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找法]]></title>
        <id>https://ACLYH.github.io/post/er-fen-cha-zhao-fa/</id>
        <link href="https://ACLYH.github.io/post/er-fen-cha-zhao-fa/">
        </link>
        <updated>2020-10-28T13:25:50.000Z</updated>
        <summary type="html"><![CDATA[<p>二分查找法是从区间[i，j]上连续不断将sum（a）·sum（b）&lt;0的函数ans=sum（x），通过循环实现把函数sum（x）的0点所在区间一分为二，如此循环，使区间[i,j]的两个端点逐渐像0点靠近，得到0点近似值的方法。可以实现空间优化，适用于数据较大的题目。时间复杂第O（log（2n））。</p>
]]></summary>
        <content type="html"><![CDATA[<p>二分查找法是从区间[i，j]上连续不断将sum（a）·sum（b）&lt;0的函数ans=sum（x），通过循环实现把函数sum（x）的0点所在区间一分为二，如此循环，使区间[i,j]的两个端点逐渐像0点靠近，得到0点近似值的方法。可以实现空间优化，适用于数据较大的题目。时间复杂第O（log（2n））。</p>
<!-- more -->
<p>在使用c++的二分查找法，要先将数据排序，二分查找法的基本思想可以这样总结：我们设数据是按升序排序的，根据题目中的数a，从序列的中间进行二分，如果当前i位置值等于a，则停止查找 ；假如a小于当前位置i，则在数列的前部分中查找；若a大于当前位置i，就在数列的后段进行查找，如果还没找到，再次二分，直到找到了a值。</p>
<p>二分例题：</p>
<p>小信的猜想<br>
Description<br>
有一天小信突发奇想，他有一个猜想，任意一个大于 2 的偶数好像总能写成 2 个质数的和。小信查了资料，发现这个猜想很早就被一个叫哥德巴赫的人提出来了，称为哥德巴赫猜想。目前还没有证明这个猜想的正确性。小信告诉你一个整数 n ，让你用这个数去验证。注意 1 不是质数。</p>
<p>Input</p>
<p>输入一个偶数 n(2&lt;n≤8000000)。</p>
<p>Output</p>
<p>输出一个整数表示有多少对 (x,y) 满足 x+y=n(x≤y) 且 x,y 均为质数。</p>
<p>Sample Input 1<br>
6<br>
Sample Output 1<br>
1<br>
Sample Input 2<br>
10<br>
Sample Output 2<br>
2<br>
——摘自YCOJ<br>
对，是一道哥德巴赫猜想。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[9000000];
bool b[9000000];
int main(){
	int n,cnt=0,k=0;
	cin &gt;&gt; n;
	for(int i=2;i&lt;n;i++){
		if(b[i]==0){
		 for(int j=i+i;j&lt;n;j+=i){
			b[j]=1;
		}
		a[k]=i;
		k++;
	}
}
	for(int i=0;i&lt;k;i++){
			//查找 
			int tmp = n-a[i];
			
			int l=i,r=k-1,mid;
			while(r-l&gt;1){
				mid=(l+r)/2;
				if(a[mid]&lt;tmp){
					l=mid+1;
				}else{
					r=mid;
				}
			}
			if(a[l] == tmp || a[r]==tmp){
				cnt++;
			}
		}
	cout &lt;&lt; cnt;
	return 0;
}
</code></pre>
<p>这道题就运用到了二分查找法，正片程序可以看做两部分，一边是主程序，一边是二分查找法的实现，用<code>while(r-l&gt;1)</code>比较并循环，判断数据是在上半部分还是下半部分，再用<code>mid=(l+r)/2;</code>进行折半查找。</p>
<h4 id="查找">查找</h4>
<p>Description</p>
<p>给出一个有 n 个元素的数列 a 和两个整数 k 和 s，其中数列 a 的元素是按照升序排列的。</p>
<p>请你在数列中找出一个元素 x，使得的 x+k=s。</p>
<p>Input</p>
<p>输入第一行一个整数 n(1≤n≤10^5)，表示数列中的元素个数。</p>
<p>接下来一行输入 n 个空格隔开的整数，表示输入的数列 a，保证是升序排列，并且 −10<sup>9≤ai≤10</sup>9。</p>
<p>接下来一行输入两个整数 k,s(−10<sup>9≤k,s≤10</sup>9)。</p>
<p>Output</p>
<p>如果能找到满足条件的数，输出&quot;Yes&quot;，否者输出&quot;No&quot;。</p>
<p>Sample Input 1</p>
<p>5<br>
1 2 3 4 5<br>
-1 4<br>
Sample Output 1</p>
<p>Yes<br>
——摘自YCOJ<br>
题目中给出了，一个重要词——升序排列，所以我们可以看出，这道题应该用二分查找法。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main () {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for(int i = 0; i &lt; n; i++){
  	cin &gt;&gt; a [i];
  }
  int k, s;
  cin &gt;&gt; k &gt;&gt; s;
  int l = 0, r = n,x = s-k;
  int mid;
  while(l &lt; r ){
  	int mid=(l+r)/2;
  	if (a[mid]&lt;x){
  	  l = mid + 1;
  }else{
	  r=mid;
	}
  }
  

	if(a[l]==x||a[r]==x) {
		cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;No&quot; ;
	}
	return 0;
}
</code></pre>
<h4 id="两数之和">两数之和</h4>
<p>Description</p>
<p>给出一个有 n 个元素的数列 a 和一个整数 s，其中数列 a 的元素是按照升序排列的。</p>
<p>请你在数列中找出两个元素 x,y使得的 x+y=s。</p>
<p>Input</p>
<p>输入第一行一个整数 n(1≤n≤10^5)，表示数列中的元素个数。</p>
<p>接下来一个输入 n 个空格隔开的整数，表示输入的数列 a，保证是升序排列，并且 −10<sup>9≤ai≤10</sup>9。</p>
<p>接下来一行输入一个整数 s(−10<sup>9≤x,s≤10</sup>9)。</p>
<p>Output</p>
<p>如果能找到满足条件的两个数，输出&quot;Yes&quot;，否者输出&quot;No&quot;。<br>
——摘自YCOJ<br>
Sample Input 1</p>
<p>5<br>
1 2 3 4 5<br>
4<br>
Sample Output 1</p>
<p>Yes<br>
Sample Input 2</p>
<p>5<br>
1 2 4 4 5<br>
4<br>
Sample Output 2</p>
<p>No<br>
同样的，二分查找。单独用两层for循环枚举是要超时的。<br>
——摘自YCOJ</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[1000010];
int main(){
	 int  n;
	 cin &gt;&gt; n;
	 int ans=0;
	 for(int i=1;i&lt;=n;i++){
	 	cin &gt;&gt; a[i];
	 }
	 int s;
	 cin &gt;&gt; s;
	 for(int i=1;i&lt;=n;i++){
	 		int l =1, r = n, x = s - a [i];
			while(r-l&gt;1){
			int	min=(l+r)/2;
				if(a[min]&lt;x){
					l=min+1;
				}else{
					r=min;
				}
			}
			if(a[l] == x ||a[r]==x){
				ans++;
			}
		}
if (ans&gt;1) {
  cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
  }else {
  cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
}
	return 0;
}
</code></pre>
<h4 id="割绳子">割绳子</h4>
<p>Description</p>
<p>现有 N 条绳子，它们的长度分别为 L1，L2，……，Ln，如果从它们中切割出 K 条长度相同的绳子，这 K 条绳子每条最长能有多长?</p>
<p>Input</p>
<p>输入共有两行，第一行包含两个正整数 N 和 K（1≤N≤1000，1≤K≤1000），用一个空格分隔；第二行包含 N 个数，依次表示 N 条绳子的长度，两数间用一个空格分隔。每条绳子的长度的小数不超过两位（1≤Li≤10000）。</p>
<p>Output</p>
<p>输出仅包含一个数，表示所得 K 条绳子的最大长度。答案四舍五入保留小数点后两位。</p>
<p>Sample Input 1</p>
<p>4 11<br>
8.02 7.43 4.57 5.39<br>
Sample Output 1</p>
<p>2.01<br>
——摘自YCOJ</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
double a[10000001];
int n,k;
int mid(double l){
	int ans=0;
	for(int i=0;i&lt;n;i++){
		ans+=a[i]/l;
	}
	return ans;
}


int main(){
	double mim;
	cin &gt;&gt; n &gt;&gt; k;
	
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
		mim = max(mim,a[i]); 
	}
	
	double l = 0,m;
	double r=mim;
	while (r-l&gt;=1e-9){       
		m=(l+r)/2;
		if(mid(m)&gt;=k){
			l=m;
		}else{
			r=m;
		}
	}
	printf(&quot;%.2lf&quot;,m);
	return 0;
}
</code></pre>
<h4 id="切割钢管">切割钢管</h4>
<p>Description</p>
<p>小白在工地干活。工地现有 nn 根钢管，第 ii 根钢管的长度为 a_ia<br>
i<br>
​	<br>
。</p>
<p>现在小白想用这 nn 根钢管来做一个支撑用的柱子。工人可以切割这些钢管成为更短的钢管，但是不能缝合两根钢管。为了安全起见，柱子必须用 至少 kk 根长度相同的钢管加上混凝土制成，并且要求钢管长度必须为 整数。</p>
<p>小白想知道，这个柱子最高能建成多高。</p>
<p>Input</p>
<p>输入第一行一个整数 n, k (1 \le n, k \le 10000)n,k(1≤n,k≤10000)。</p>
<p>接下来一行输入 nn 个空格隔开的整数 a_i(1 \le l_i \le 10^8)a<br>
i<br>
​	<br>
(1≤l<br>
i<br>
​	<br>
≤10<br>
8<br>
)，表示每根钢管的长度。</p>
<p>Output</p>
<p>输出能够得到的柱子最大高度。</p>
<p>Sample Input 1</p>
<p>2 4<br>
8 4<br>
Sample Output 1</p>
<p>2<br>
Sample Input 2</p>
<p>8 8<br>
12 3 14 12 14 20 4 8<br>
Sample Output 2</p>
<p>7</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[1000010];
int n,k;
int cnt(int len){
	int ans=0;
	for (int i=0;i&lt;n;i++){ 
		ans +=a[i]/len;
	}
	return ans;
}
int main(){
	cin &gt;&gt; n &gt;&gt; k;
 int mx=0;
	for (int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
      mx=max(mx,a[i]);
	}
	int l=0,r=mx,x;
	while (r-l &gt; 1){
		x=(l+r)/2;
		if (cnt(x)&gt;=k){
			l = x;
		}
		else {
			r = x - 1;
		}
	}
	
    if(cnt(r) &lt; k){
    	r=l;
	}
	cout &lt;&lt; r;
	return 0;
}
</code></pre>
<h4 id="火车站台连锁店">火车站台连锁店</h4>
<p>Description</p>
<p>蒜头君建立了一家火车站台连锁店，要在一条铁路线的所有车站里，选择一部分车站开办连锁店，销售各种口味的大蒜。</p>
<p>铁路线上有 nn 个车站，假设这条铁路线是一条直线，其中每个站点的坐标为 x_1,x_2,\ldots,x_nx<br>
1<br>
​	<br>
,x<br>
2<br>
​	<br>
,…,x<br>
n<br>
​	<br>
。</p>
<p>蒜头君一共要开办 mm 个连锁店，并且不希望连锁店离得太近，以使得整体的收益最大化。他希望他的连锁店之间的最近距离尽可能大，你能帮他算出这个最大的最近距离吗？</p>
<p>Input</p>
<p>第一行输入用空格分隔的两个整数 n,m(2 \10^5, 2 \ m  n)n,m(2≤n≤10<br>
5<br>
,2≤m≤n)，分别表示车站数量和连锁店数量。</p>
<p>接下来一共 nn 行，每行一个整数 x_i{0 \leq x_i \leq 10^9}x<br>
i<br>
​	<br>
0≤x<br>
i<br>
​	<br>
≤10<br>
9<br>
，表示车站的坐标。</p>
<p>Output</p>
<p>输出一行整数，表示最大的最近距离。</p>
<p>Sample Input 1</p>
<p>6 3<br>
1<br>
3<br>
5<br>
2<br>
7<br>
9<br>
Sample Output 1</p>
<p>4<br>
Sample Input 2</p>
<p>5 4<br>
5<br>
7<br>
10<br>
28<br>
9<br>
Sample Output 2</p>
<p>2</p>
<pre><code>#include&lt;bits/stdc++.h&gt; 
using namespace std;
int a[1000010];
int n,m;
int cnt(int len){
	int tot=1;
	int last = 0;
	for(int i = 1;i&lt;n;i++){
		if(a[i] - a[last] &gt;= len){
		   	tot++;
			last = i;
        }
    }
	return tot;
}
int main (){ 
	cin &gt;&gt; n &gt;&gt; m;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
	}
	sort(a,a+n);
	int l=0,r=a[n - 1],ans;
	while (r - l &gt; 1){
	    ans=(l+r)/2;
		if (cnt(ans) &gt;= m){
			l = ans;
	    }
		else{
			r = ans;
		}
	}
	if(cnt(r)&lt;m){
		r = l;
	}
	cout &lt;&lt; r;
	return 0; 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路算法]]></title>
        <id>https://ACLYH.github.io/post/zui-duan-lu-suan-fa/</id>
        <link href="https://ACLYH.github.io/post/zui-duan-lu-suan-fa/">
        </link>
        <updated>2020-10-28T13:21:37.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1dijkstra">1.Dijkstra</h4>
<p>Dijkstra用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算<br>
法的主要特点是以起点为中心，逐层向外扩展一个点，每次都会取一个最近点继续扩展，直到取完所有点为止。但Dijkstra 算法要求图中不能出现负权边。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1dijkstra">1.Dijkstra</h4>
<p>Dijkstra用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算<br>
法的主要特点是以起点为中心，逐层向外扩展一个点，每次都会取一个最近点继续扩展，直到取完所有点为止。但Dijkstra 算法要求图中不能出现负权边。</p>
<!-- more -->
<pre><code>//模板
#include&lt;bits/stdc++.h&gt;
using namespace std;


int n,m;

struct node{
	int v,w;
	node(){ };
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
int dst[10100];

void add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){
	memset(dst,0x3f,sizeof dst);
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			int w = g[u][j].w;
			dst[v] = min(dst[v],dst[u]+w);
			
		}
		
		int mi=0x3f3f3f3f;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v,w;
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	
	dij(1);
	cout &lt;&lt; dst[n];
	
	return 0;
}
</code></pre>
<h4 id="2spfa">2.SPFA</h4>
<p>SPFA算法是单源最短路径的一种算法，通常被认为是 Bellmanford算法的队列优化，在代码形式上接近宽度优先搜索 BFS，是一个在实践中非常高效的单源最短路算法。它会在每次更新了最短路以后又重新入队从而去更新后续结点的最短路。同时有些题有卡SPFA的数据，所以也可以换成Dijkstra。但Dijkstra 不能处理有负权的图，而 SPFA 可以处理不含负环的图的最短路，并能 判断是否存在负环。</p>
<pre><code>//模板
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=1010;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
int inq[maxn];

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}

void spfa(int s){
	memset(dst,inf,sizeof dst);
	int u=s;
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	int u , v , w; 
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	spfa(1);
	cout &lt;&lt; dst[n]&lt;&lt;endl;
	return 0;
}
</code></pre>
<h4 id="floyd">Floyd</h4>
<p>基于动态规划思想，个人认为Floyd较Dijkstra和SPFA更难理解，所以就不写太多，但代码很短。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e2 + 9;
const int inf = 0x3f3f3f3f;
int mp[N][N];
void floyd(int n) {
	for (int k = 1; k &lt;= n; ++k) {
		for (int i = 1; i &lt;= n; ++i) {
			for (int j = 1; j &lt;= n; ++j) {
				mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
			}
		}
	}
}
int main() {
	memset(mp, inf, sizeof mp);
	for (int i = 0; i &lt; N; ++i) {
		mp[i][i] = 0;
	}
int n, m;
int u, v, w;
cin &gt;&gt; n &gt;&gt; m;
	while (m--) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		mp[u][v] = mp[v][u] = w;
	}
	floyd(n);
	for (int i = 1; i &lt;= n; ++i) {
		for (int j = 1; j &lt;= n; ++j) {
			cout &lt;&lt; mp[i][j] &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
return 0;
}
</code></pre>
<h4 id="一些最短路的题目">一些最短路的题目</h4>
<h5 id="1迷阵突围">1.迷阵突围</h5>
<pre><code>

Description

小信陷入了坐标系上的一个迷阵，迷阵上有 n个点，编号从 1 到 n。小信在编号为 1 的位置，他想到编号为 n 的位置上。小信当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在小信知道了 n 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

注意，每条路径上不能重复经过同一个点。

Input

第一行输入两个整数 n (1≤n≤200) 和 m，表示一共有 n 个点和 m 条边。

接下来输入 n 行，每行输入两个整数 xi,yi (−500≤xi,yi≤500)，代表第 i 个点的坐标。

接下来输入 m 行，每行输入两个整数 pj,qj (1≤pj,qj≤n)，表示点 pj 和点 qj 之间相连。

Output

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 -1。

Sample Input 1

3 3
1 1
2 2
3 2
1 2
2 3
1 3

Sample Output 1

2.41


</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,m;

struct node{
	int v;
	double w;
	node(){ };
	node(int _v,double _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
double dst[10100];

int x[10100],y[10100];
int pre[10100];
void add(int u,int v,double w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){

	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				pre[v]=u;
			}
		}
		
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}

}


void dij2(int s,int uu,int vv){
	
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(uu ==u &amp;&amp; vv==v || uu==v &amp;&amp; vv == u){
				continue;
			}
	
			dst[v] = min(dst[v],dst[u]+w);

	}
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	 
	}

}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v;
	double w;
	
	for(int i=1;i&lt;=n;i++){
		cin &gt;&gt; x[i] &gt;&gt;y[i];
	}
	
	while (m--){
		cin &gt;&gt; u &gt;&gt; v;
		w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
		add(u,v,w);
	}
	
	dij(1);

	
	double mi=1e20;
	for(int i=n;pre[i]!=0;i=pre[i]){
		dij2(1,i,pre[i]);
		mi=min(mi,dst[n]);
	}
	     if(mi == 1e20){
	      cout &lt;&lt; &quot;-1&quot;&lt;&lt;endl;
		 }else{
			 cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mi&lt;&lt;endl;
		}
	
	return 0;
}
</code></pre>
<h5 id="2p1359-租用游艇">2.P1359 租用游艇</h5>
<pre><code>
题目描述

长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt;=i&lt;=j&lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。

对于给定的游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n，编程计算从游艇出租站1 到游艇出租站n所需的最少租金。

保证计算过程中任何时刻数值都不超过10^6
输入输出格式
输入格式：

由文件提供输入数据。文件的第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是一个半矩阵r(i,j),1&lt;=i&lt;j&lt;=n。

输出格式：

程序运行结束时，将计算出的从游艇出租站1 到游艇出租站n所需的最少租金输出到文件中。

输入输出样例
输入样例#1： 

3
5 15
7

输出样例#1： 

12


</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int maxn=0x3f3f3f3f; 
int vis[100001];
int dist[10001];
int a[1001][1001];
int main(){
   int n,j,k,l,i;
     cin&gt;&gt;n;
   for(j=0;j&lt;=n;j++){
     for(k=0;k&lt;=n;k++){
        a[j][k]=maxn;
        if(j==k)
            a[j][k]=0;
     }
     dist[j]=maxn;
   }
 
   for(j=1;j&lt;=n;j++){
      for(k=j+1;k&lt;=n;k++){
         cin&gt;&gt;a[j][k];
      }
   }
 
   for(j=1;j&lt;=n;j++){
      dist[j]=a[1][j];
   }
   memset(vis,0,sizeof vis);
   vis[1]=1;
   for(j=1;j&lt;=n;j++){
      int mi=maxn;
      for(i=1;i&lt;=n;i++){
          if(!vis[i]&amp;&amp;dist[i]&lt;mi){
              mi=dist[i];
              k=i;
          }
      }
      vis[k]=1;
 
      for(i=1;i&lt;=n;i++){
          if(!vis[i]&amp;&amp;a[k][i]+dist[k]&lt;dist[i]){
              dist[i]=dist[k]+a[k][i];
          }
      }
  
   }
   cout&lt;&lt;dist[n]&lt;&lt;endl;
 
   return 0;
}
</code></pre>
<h5 id="3p3371-模板单源最短路径弱化版">3.P3371 【模板】单源最短路径（弱化版）</h5>
<p><a href="https://blog.csdn.net/weixin_43913349/article/details/89278981">传送门</a></p>
<h5 id="4p1339-usaco09oct热浪heat-wave">4.P1339 [USACO09OCT]热浪Heat Wave</h5>
<pre><code>
题目描述

The good folks in Texas are having a heatwave this summer. Their Texas Longhorn cows make for good eating but are not so adept at creating creamy delicious dairy products. Farmer John is leading the charge to deliver plenty of ice cold nutritious milk to Texas so the Texans will not suffer the heat too much.

FJ has studied the routes that can be used to move milk from Wisconsin to Texas. These routes have a total of T (1 &lt;= T &lt;= 2,500) towns conveniently numbered 1..T along the way (including the starting and ending towns). Each town (except the source and destination towns) is connected to at least two other towns by bidirectional roads that have some cost of traversal (owing to gasoline consumption, tolls, etc.). Consider this map of seven towns; town 5 is the

source of the milk and town 4 is its destination (bracketed integers represent costs to traverse the route):


                              [1]----1---[3]-
                             /               \
                      [3]---6---[4]---3--[3]--4
                     /               /       /|
                    5         --[3]--  --[2]- |
                     \       /        /       |
                      [5]---7---[2]--2---[3]---
                            |       /
                           [1]------

Traversing 5-6-3-4 requires spending 3 (5-&gt;6) + 4 (6-&gt;3) + 3 (3-&gt;4) = 10 total expenses.

Given a map of all the C (1 &lt;= C &lt;= 6,200) connections (described as two endpoints R1i and R2i (1 &lt;= R1i &lt;= T; 1 &lt;= R2i &lt;= T) and costs (1 &lt;= Ci &lt;= 1,000), find the smallest total expense to traverse from the starting town Ts (1 &lt;= Ts &lt;= T) to the destination town Te (1 &lt;= Te &lt;= T).

德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。

FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T (1 &lt;= T &lt;= 2,500)个城镇，方便地标号為1到T。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。

给定一个地图，包含C (1 &lt;= C &lt;= 6,200)条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re (1 &lt;= Rs &lt;= T; 1 &lt;= Re &lt;= T)，和花费(1 &lt;= Ci &lt;= 1,000)组成。求从起始的城镇Ts (1 &lt;= Ts &lt;= T)到终点的城镇Te(1 &lt;= Te &lt;= T)最小的总费用。
输入输出格式
输入格式：

第一行: 4个由空格隔开的整数: T, C, Ts, Te

第2到第C+1行: 第i+1行描述第i条道路。有3个由空格隔开的整数: Rs, Re和Ci

输出格式：

一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。

输入输出样例
输入样例#1： 复制

7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1

输出样例#1： 复制

7

说明

【样例说明】

5-&gt;6-&gt;1-&gt;4 (3 + 1 + 3)

</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int inf=10100;
queue&lt;int&gt; qu;
int dst[inf];
bool inq[inf];
struct node{
    int t,dist;
};
vector&lt;node&gt; g[inf];
bool spfa(int s){
    memset(dst,0x7f,sizeof(dst));
    memset(inq,0,sizeof(inq));
    dst[s]=0;
    qu.push(s);
    inq[s]=true;
    while(!qu.empty()){
        int u=qu.front();
        qu.pop();
        inq[u]=0;
        for(int i=0;i&lt;g[u].size();i++){
            int v=g[u][i].t;
            int w=g[u][i].dist;
            if(dst[u]+w&lt;dst[v]){
                dst[v]=dst[u]+w;
                if(!inq[v])
                {
                    qu.push(v);
                    inq[v]=1;
                }
            }
        }
    }
}
int main()
{
    int n,m,st,en;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;en;
    for(int i=0;i&lt;m;i++){
        int x,y,v;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
        g[x].push_back((node){y,v});
        g[y].push_back((node){x,v});
    }
    spfa(st);
    cout&lt;&lt;dst[en];
    return 0;
}
</code></pre>
<p><s>可能你已经发现没有一个用的Floyd，只是因为太蒟了。</s></p>
<h2 id="欧拉回路">欧拉回路</h2>
<p>若图中存在这样一条路径，使得它恰好通过图中每条边一次，则称该路径为 欧拉路径。若该路径<br>
是一个环路，则称为 欧拉（Euler）回路。</p>
<p>1.无向图有欧拉回路的条件<br>
一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数,且该图是连通图。<br>
2.有向图有欧拉回路的条件<br>
一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。</p>
<p>然后，其实也挺简单的。</p>
<p>一道模板题：</p>
<pre><code>题目背景

Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。
题目描述

John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。

每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。

你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。

输入数据保证至少有一个解。
输入输出格式
输入格式：

第1行: 一个整数F(1 &lt;= F &lt;= 1024)，表示栅栏的数目

第2到F+1行: 每行两个整数i, j(1 &lt;= i,j &lt;= 500)表示这条栅栏连接i与j号顶点。

输出格式：

输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。

输入输出样例
输入样例#1： 复制

9
1 2
2 3
3 4
4 2
4 5
2 5
5 6
5 7
4 6

输出样例#1： 复制

1
2
3
4
2
5
4
6
5
7


</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1010;
int n;
int eul[maxn][maxn],lu[maxn];
int sum=0;

stack&lt;int&gt; sta;


void dfs(int s){
    for(int i=1;i&lt;=500;i++){
        if(eul[s][i]){
        eul[i][s]--;
        eul[s][i]--;
        
        dfs(i);	
        }
    }
    sta.push(s);
}


int main(){
    
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
    	int x;
    	int y;
    	cin&gt;&gt; x &gt;&gt; y;
    	eul[x][y]++;
    	eul[y][x]++;
    	lu[x]++;
    	lu[y]++;
    }
    int num=1;
    for(int i=1;i&lt;=500;i++){
        if(lu[i]%2){
            num=i;
            break;
        }
    }
    dfs(num);
    while(!sta.empty()){
    	cout &lt;&lt; sta.top()&lt;&lt;endl;
    	sta.pop();
    }
    	
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[DFS]排队（间隔排列）]]></title>
        <id>https://ACLYH.github.io/post/dfspai-dui-jian-ge-pai-lie/</id>
        <link href="https://ACLYH.github.io/post/dfspai-dui-jian-ge-pai-lie/">
        </link>
        <updated>2020-10-28T13:20:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="description">Description</h2>
<p>小Q是班长。在校运动会上，小Q班要进行队列表演。小Q要选出2*N名同学编队，每人都被编上一个号，每一个从1到N的自然数都被某2名同学佩戴，现在要求将他们排成一列，使两个编号为1的同学中间恰好夹1名同学，两个编号为2的同学中间恰好夹2名同学，……，两个编号为N的同学中间恰好夹N名同学，小Q希望知道这样的排法能否实现。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>小Q是班长。在校运动会上，小Q班要进行队列表演。小Q要选出2*N名同学编队，每人都被编上一个号，每一个从1到N的自然数都被某2名同学佩戴，现在要求将他们排成一列，使两个编号为1的同学中间恰好夹1名同学，两个编号为2的同学中间恰好夹2名同学，……，两个编号为N的同学中间恰好夹N名同学，小Q希望知道这样的排法能否实现。</p>
<!-- more -->
<h2 id="input">Input</h2>
<p>输入文件仅包括一行，即要处理的N。N&lt;=13</p>
<h2 id="output">Output</h2>
<p>输出有多少种排列顺序.</p>
<h2 id="sample-input">Sample Input</h2>
<p>3</p>
<h2 id="sample-output">Sample Output</h2>
<p>2</p>
<p>先理解一下题目，题目中所述，每一个从1到N的自然数都被某2名同学佩戴，说明共有2N名同学，两个编号为N的同学中间恰好夹N名同学，就可以得到一个排列（以n==3为例）：</p>
<p><img src="https://img-blog.csdnimg.cn/20190714092334172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
然后，就可以用DFS搜索了。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,ans=0;
int flag[100]={0};

void dfs(int dep){
	
	if(dep&gt;n){
		ans++;
		return ;
	}
	for(int i=1;i&lt;=2*n-dep-1;i++){
		if(!flag[i]&amp;&amp;!flag[i+dep+1]){//考虑当前位置有无其他数，和它的间隔有没有其他数
			flag[i]=flag[i+dep+1]=1;
			dfs(dep+1);
			flag[i]=flag[i+dep+1]=0;
		}
	}
}
int main(){
	cin &gt;&gt; n;
	dfs(1);
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
<p>但是，可以发现，当程序运行12或13时，耗时很长，那么就可以想到剪枝优化。</p>
<pre><code>	if(n%4==1||n%4==2){
		return ; 
	}
</code></pre>
<p>现在，就可以证明一下这个剪枝的得到。<br>
设问题的一个解为a1+a2···+an,a1表示1。<br>
那么可以得到  a1+a2+…+an+(a1+1+1)+(a2+2+1)+…+(an+n+1) ，最后解得 4(a1+a2+…+an)=n(3n-1) ，所以n%4<mark>1或n%4</mark>2无解。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,ans=0;
int flag[100]={0};

void dfs(int dep){
	
	if(n%4==1||n%4==2){
		return ; 
	}
	if(dep&gt;n){
		ans++;
		return ;
	}
	for(int i=1;i&lt;=2*n-dep-1;i++){
		if(!flag[i]&amp;&amp;!flag[i+dep+1]){
			flag[i]=flag[i+dep+1]=1;
			dfs(dep+1);
			flag[i]=flag[i+dep+1]=0;
		}
	}
}
int main(){
	cin &gt;&gt; n;
	dfs(1);
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-10-27 模拟考]]></title>
        <id>https://ACLYH.github.io/post/2020-10-27-mo-ni-kao/</id>
        <link href="https://ACLYH.github.io/post/2020-10-27-mo-ni-kao/">
        </link>
        <updated>2020-10-28T11:06:16.000Z</updated>
        <summary type="html"><![CDATA[<p>三道题目，有两道还是普及组T3和T4原题。。。<br>
<s>然鹅我似乎还是炸了呢</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>三道题目，有两道还是普及组T3和T4原题。。。<br>
<s>然鹅我似乎还是炸了呢</s></p>
<!-- more -->
<p>T1<br>
<a href="https://www.luogu.com.cn/problem/P5661">公交换乘</a><br>
著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：</p>
<p>在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：tbus−tsubway≤45<br>
搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。<br>
搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。<br>
现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?</p>
<p>输入格式<br>
输入文件的第一行包含一个正整数 n，代表乘车记录的数量。</p>
<p>接下来的 n 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。第 i 行的第 1 个整数代表第 i条记录乘坐的交通工具，0 代表地铁，1 代表公交车；第 2 个整数代表第 i 条记录乘车的票价 price<br>
i<br>
​	<br>
；第三个整数代表第 i 条记录开始乘车的时间 t<br>
i<br>
​	<br>
（距 0 时刻的分钟数）。</p>
<p>我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。</p>
<p>输出格式<br>
输出文件有一行，包含一个正整数，代表小轩出行的总花费。</p>
<p>输入输出样例<br>
输入 #1</p>
<pre><code>6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135
输出 #1
36
输入 #2
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 
输出 #2
32
</code></pre>
<p>乘坐地铁的价格可以直接加入ans，主要处理在公交车是否免费的判断上。<br>
因为队列的性质是先进先出，而题目恰好要求如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。所以可以模拟队列，其中用一个结构体来表示优惠票的改变。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int pr,time,use;
}q[110001];//免费票的价格上限，能用的时间，是否可用；
int n;
int op,pri,ti,ans;
int tail,head;//模拟队列
int main(){
	cin &gt;&gt; n;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; op &gt;&gt; pri &gt;&gt; ti;
		if(op==0){//如果是地铁的情况
			ans+=pri;//直接将价格加入ans
			q[tail].time = ti + 45;//时间范围
			q[tail++].pr = pri; //存入票价
		}else if(op == 1){//公交车
			while (head &lt; tail &amp;&amp; q[head].time &lt; ti) {
                head++;
            }//放弃超过时间限制的票
            bool flag = 0;//标记
            for(int j=head;j&lt;tail;j++){
            	if(q[j].pr &gt;= pri &amp;&amp; q[j].use == 0){//如果存在免费票大于公交车价格的票，且没有没用过
            		flag = 1;
            		q[j].use = 1;//标记为用过
            		break;
				}
			}	
		if(!flag){
			ans+=pri;//如果不行，就将价格直接加入ans
		}
		}
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<p>T2<br>
<a href="https://www.luogu.com.cn/problem/P5018">对称二叉树</a><br>
<s>有一道做过好几遍的题</s><br>
当时在NOI考场上我一脸懵逼，现在想来······</p>
<p>一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：<br>
二叉树；<br>
将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。<br>
下图中节点内的数字为权值，节点外的 id 表示节点编号。</p>
<p>现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。</p>
<p>注意：只有树根的树也是对称二叉树。本题中约定，以节点 TT 为子树根的一棵“子 树”指的是：节点TT 和它的全部后代节点构成的二叉树。</p>
<p>输入格式<br>
第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1∼n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，其中节点 11 是树根。</p>
<p>第二行 n 个正整数，用一个空格分隔，第 i 个正整数 v_i 代表节点 i 的权值。</p>
<p>接下来 n 行，每行两个正整数 l_i, r_i ，分别表示节点 ii 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1−1 表示。两个数之间用一个空格隔开。<br>
输出格式<br>
输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。<br>
输入输出样例</p>
<pre><code>输入 #1
2 
1 3 
2 -1 
-1 -1 
输出 #1
1
输入 #2
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8
输出 #2
3
</code></pre>
<p>DFS可以水过去。<br>
搜索思路比较好想，以每个节点为根节点，判断左子树的值是否等于右子树值，就能找到它们是否是对称二叉树。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n;
int l[1010000],r[1010010];//左子树，右子树
bool vis;int a[10100100];
int ans=1 ;
int dfs(int x,int y,int s)//正在访问的节点，s为当前节点。
{
	if(x==-1&amp;&amp;y==-1)return 0;//返回条件
	if(x==-1||y==-1&amp;&amp;x!=y){
		vis=1;
		return 0;	
	}//对称二叉树
	if(a[x]!=a[y]){
		vis=1;
		return 0;
	}//对称
	return  dfs(l[x],r[y],2) + dfs(r[x],l[y],2) + s;
}

int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
	}
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]);
	}
	for(int i=1;i&lt;=n;i++){
		if(dfs(l[i],r[i],3)&gt;ans&amp;&amp;vis==0){
			ans = dfs(l[i],r[i],3);
		}
		vis = 0;
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<p>T3<br>
<a href="http://forioi.com/p/6217">photo</a></p>
<p>啊这。。状压DP？<s>（然鹅考场上并不会）</s></p>
<p>有N个人，来自K个家族.他们排成一行准备照相，但是由于天生的排外性，每个人都希望和本家族的人站在一起,中间不要加入别的家族的人.问最少从队列中去掉多少个就可以达到这个目的.<br>
输入<br>
第一行给出N,K。N在[1,100]，K在[1,5] 第二行给出N个数，每个数为1到K中的某个数。<br>
输出<br>
最少从队列中去掉多少个就可以达到这个目的</p>
<p>样例<br>
输入<br>
10 3<br>
2 1 2 2 1 1 3 1 3 3</p>
<p>输出<br>
2</p>
<p>DP求解可以保留最多的人数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">n-ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>即为所求。<br>
所以就看那种方法最优，要么当前状态是一个新的家族，要么保持连通，当前这个人与上一个同属于一个家族。</p>
<p>用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>三个量来表示第i个人，第j状态，前一个人是第K家族的保留人数。</p>
<p>一为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><msup><mi>j</mi><mo>(</mo></msup><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>1</mn><mo>)</mo><mo>]</mo><mo>[</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j ^ (1 &lt;&lt; a[i] - 1)][+ 1);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">+</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span> 当前出现的家族。<br>
二为与上一个家族的人相同，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j][a[i]] + 1);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 int ans = 0;
int n, k, a[101001];
int dp[200][1000][10];
int main() {
    cin &gt;&gt; n &gt;&gt;k;
    for(int i = 1; i &lt;= n; i++){
    cin &gt;&gt; a[i];	
    }
     
    for(int i = 1; i &lt;= n; i++) {
        memcpy(dp[i], dp[i - 1], sizeof dp[i - 1]);
                 
        for(int j = 0; j &lt; (1 &lt;&lt; k); j++) {
            if(j &amp; (1 &lt;&lt; a[i] - 1)) {
                dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j][a[i]] + 1);
                for(int l = 0; l &lt;= k; l++){
                	dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j ^ (1 &lt;&lt; a[i] - 1)][l] + 1);
            		}
				}     
        }
    }
    for(int j = 0; j &lt; (1 &lt;&lt; k); j++)
        for(int l = 0; l &lt;= k; l++) 
            ans = max(ans, dp[n][j][l]);
             
    cout &lt;&lt;  n - ans;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分约束]]></title>
        <id>https://ACLYH.github.io/post/chai-fen-yue-shu/</id>
        <link href="https://ACLYH.github.io/post/chai-fen-yue-shu/">
        </link>
        <updated>2020-10-28T10:57:40.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1差分约束系统system-of-difference-constraints">1.差分约束系统（system of difference constraints）</h4>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1差分约束系统system-of-difference-constraints">1.差分约束系统（system of difference constraints）</h4>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。</p>
<!-- more -->
<p>求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。<br>
——百度百科<br>
如下列的不等式组</p>
<pre><code>x1-x5≤-1
x2-x5≤1
x3-x1≤5
x4-x1≤4
x4-x3≤-1
x5-x3≤-3
x5-x4≤-3
</code></pre>
<p>比如1式 x1-x5≤-1，其中一个未知数x1与x5的差小于等于-1，就相当于设两个未知数x，y差为某一常数，由这些不等式构成的不等式方程组为差分约束系统。</p>
<h4 id="2例题">2.例题</h4>
<h6 id="小k的农场">小K的农场</h6>
<p>关于洛谷一道蓝题。<br>
<a href="https://www.luogu.org/problemnew/show/P1993">P1993 小K的农场</a><br>
但因为在另一篇题解中写过了，所以不多做阐述，解题看好差分约束条件就行了。<br>
<a href="https://blog.csdn.net/weixin_43913349/article/details/89280139">小K的农场（差分约束）题解</a></p>
<p>然后是另外两道题</p>
<h6 id="蒜头君的银行卡">蒜头君的银行卡</h6>
<p>Description</p>
<p>虽然蒜头君并没有多少钱，但是蒜头君办了很多张银行卡，共有 n 张，以至于他自己都忘记了每张银行卡里有多少钱了。他只记得一些含糊的信息，这些信息主要以下列三种形式描述：</p>
<p>银行卡 a 比银行卡 b 至少多 c 元。<br>
银行卡 a 比银行卡 b 至多多 c 元。<br>
银行卡 a 和银行卡 c 里的存款一样多。<br>
但是由于蒜头君的记忆有些差，他想知道是否存在一种情况，使得银行卡的存款情况和他记忆中的所有信息吻合。</p>
<p>Input<br>
第一行输入两个整数 n 和 m，分别表示银行卡数目和蒜头君记忆中的信息的数目。(1≤n,m≤10000)</p>
<p>接下来 m 行：</p>
<p>如果每行第一个数是 1，接下来有三个整数 a,b,c，表示银行卡 a 比银行卡 b 至少多 c元。</p>
<p>如果每行第一个数是 2，接下来有三个整数 a,b,c，表示银行卡 a 比银行卡 b 至多多 c元。</p>
<p>如果每行第一个数是 3，接下来有两个整数 a,b，表示银行卡 a 和 b 里的存款一样多。(1≤n,m,a,b,c≤10000)</p>
<p>Output<br>
如果存在某种情况与蒜头君的记忆吻合，输出Yes，否则输出No。</p>
<p>Sample Input 1</p>
<p>3 3<br>
3 1 2<br>
1 1 3 1<br>
2 2 3 2<br>
Sample Output 1</p>
<p>Yes</p>
<p>很明显，题目中出现了几个约束条件：<br>
银行卡 a 比银行卡 b 至少多 c 元。<br>
银行卡 a 比银行卡 b 至多多 c 元。<br>
银行卡 a 和银行卡 c 里的存款一样多。</p>
<p>转化为不等式方程组：</p>
<p>a-b&gt;=c<br>
a-b&lt;=c<br>
a=c</p>
<p>找到了解题的关键，然后将差分约束转化为最短路求解 。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10100;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
bool inq[maxn];
int cnt[maxn];


int add(int u,int v,int w){
	g[u].push_back(node(v,w));
//	g[v].push_back(node());
}

int spfa(int u){
	memset(inq,0,sizeof inq);
	memset(dst,inf,sizeof dst);
	memset(cnt,0,sizeof cnt);
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	cnt[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
					cnt[v]++;
					if(cnt[v]&gt;n+1){
					return 0;	
					}
				}
			}
		}
	}
	return 1;
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	
	for(int i=0;i&lt;m;i++){
		int d,a,b,c;
		cin &gt;&gt; d;
		if(d==1){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a].push_back(node(b,-c));
		}else if(d==2){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[b].push_back(node(a,-c));
		}else{
			cin &gt;&gt;a&gt;&gt;b;
			g[a].push_back(node(b,0));
			g[b].push_back(node(a,0));
		}
	}
	
	for(int i=1;i&lt;=n;i++){
		add(0,i,0);
	}
	if(spfa(0)){
	cout &lt;&lt; &quot;Yes&quot;&lt;&lt;endl;
}else{
	cout &lt;&lt; &quot;No&quot;;
}
	return 0;
}
</code></pre>
<h6 id="蒜头君当大厨">蒜头君当大厨</h6>
<pre><code>Description

蒜头君苦练厨艺，终于成为了某高档酒店的大厨。

每天上班，蒜头君会被要求做 n 份菜。既然是高档酒店，那么客人们当然是很讲究的，尤其对于上菜的时间有很多要求。客人们的要求被分成下列四种：

菜品 a 的上菜时间必须比菜品 b 的上菜时间早 d 分钟或者更早。

菜品 a 的上菜时间必须比菜品 b 的上菜时间迟 d 分钟或者更迟。

菜品 a 的上菜时间在 d 分钟以后(包含 d 分钟)。

菜品 a 的上菜时间在 d 分钟之前(包含 d 分钟)。

蒜头君的上班时间记为 0 分钟。为了节约时间，在满足客人们要求的情况下，蒜头君希望最后上的一道菜的时间尽可能的早。（每道菜的上菜时间必须不早于蒜头君的上班时间）


Input
第一行输入一个整数 n，表示一共需要上 n 道菜。

第二行输入一个整数 m，表示客人们的要求数量。

接下里 m 行，每行先输入一个整数 op。

如果 op=1，表示描述里的第 1 种要求，后面跟着三个整数 a,b,d。
如果 op=2，表示描述里的第 2 种要求，后面跟着三个整数 a,b,d。
如果 op=3，表示描述里的第 3 种要求，后面跟着两个整数 a,d。
如果 op=4，表示描述里的第 4 种要求，后面跟着两个整数 a,d。

Output
如果蒜头君能满足客人们的要求，输出最后一道菜的上菜时间；否则输出一行 'I can't'。

数据范围和约定

对于所有的数据：1≤n,m≤20000，1≤∣d∣≤10000 ,1≤a,b≤n，a≠b。

样例解释 1

1,2,3 的上菜时间分别为 0,2,12，这样能满足输入客人们的所有要求，并且时间最短。



Sample Input 1 

3
5
2 3 2 10
2 2 1 2
2 3 2 5
1 2 3 7
3 3 9
Sample Output 1

12
Sample Input 2 

3
4
3 1 3
2 3 1 9
2 1 3 -1
1 1 2 5
Sample Output 2

I can't
Sample Input 3 

17
20
2 6 3 -21
1 8 2 54
3 7 -95
4 11 44
1 5 15 40
3 9 1
3 3 30
3 8 23
2 9 12 -15
4 13 61
2 3 7 31
1 5 10 -15
2 16 1 43
2 12 3 -79
2 14 16 -51
3 6 48
4 7 0
2 10 11 -59
2 12 17 -29
3 4 10
Sample Output 3

77
</code></pre>
<p>与蒜头君的银行卡差不多，都是找到差分约束条件：<br>
菜品 a 的上菜时间必须比菜品 b 的上菜时间早 d 分钟或者更早。</p>
<p>菜品 a 的上菜时间必须比菜品 b 的上菜时间迟 d 分钟或者更迟。</p>
<p>菜品 a 的上菜时间在 d 分钟以后(包含 d 分钟)。</p>
<p>菜品 a 的上菜时间在 d 分钟之前(包含 d 分钟)。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=20010;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
bool inq[maxn];
int cnt[maxn];
int flag;

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
//	g[v].push_back(node());
}

void spfa(int u){
	memset(inq,0,sizeof inq);
	memset(dst,0x80,sizeof dst);
	memset(cnt,0,sizeof cnt);
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	cnt[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&lt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
					cnt[v]++;
					if(cnt[v]&gt;n+1){
						return;
					}
					if(cnt[v]==n+1){
						flag=1;
					}
				}
			}
		}
	}
	return;
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	
	for(int i=0;i&lt;m;i++){
		int d,a,b,c;
		cin &gt;&gt; d;
		if(d==1){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a].push_back(node(b,c));
		}else if(d==2){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[b].push_back(node(a,c));
		}else if(d==3){
			cin &gt;&gt;a&gt;&gt;b;
			g[0].push_back(node(a,b));
		}else{
			cin &gt;&gt;a&gt;&gt;b;
			g[0].push_back(node(0,-b));
		}
	}
	
	for(int i=1;i&lt;=n;i++){
		add(0,i,0);
	}
int ans=0;
spfa(0);

if(flag){
	cout&lt;&lt;&quot;I can't&quot;;
	return 0;
}
 
 for(int i=1;i&lt;=n;i++){
 ans=max(ans,dst[i]);
}
cout &lt;&lt; ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>