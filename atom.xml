<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ACLYH.github.io</id>
    <title>Lanthanum</title>
    <updated>2020-10-25T08:38:31.273Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ACLYH.github.io"/>
    <link rel="self" href="https://ACLYH.github.io/atom.xml"/>
    <subtitle>心之所向，素履以往，生如逆旅，一苇以航。</subtitle>
    <logo>https://ACLYH.github.io/images/avatar.png</logo>
    <icon>https://ACLYH.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Lanthanum</rights>
    <entry>
        <title type="html"><![CDATA[栈]]></title>
        <id>https://ACLYH.github.io/post/zhan/</id>
        <link href="https://ACLYH.github.io/post/zhan/">
        </link>
        <updated>2020-10-25T08:37:05.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>一个，跟队列同样基础的数据结构。。。<br>
栈就是一种有限制的线性表，限制在于它只能先进后出。栈顶的第一个元素是栈顶元素，相反的是栈底。相当于吃薯片时，将薯片装入桶中为进栈，拿出来为出栈。</p>
<p>###STL库</p>
<pre><code>stack&lt;T&gt;//T为一种变量类型
</code></pre>
<p>###stack操作</p>
<pre><code>push()-入栈
pop()-出栈
clear()-清空栈
top()-取栈顶元素
size()-栈的大小
empty()-清空栈
</code></pre>
<p>图论中的欧拉回路就有一定栈的使用。<br>
<a href="https://www.luogu.org/problem/P2731">P2731 骑马修栅栏 Riding the Fences<br>
</a></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1010;
int n;
int eul[maxn][maxn],lu[maxn];
int sum=0;

stack&lt;int&gt; sta;//开一个栈

void dfs(int s){
    for(int i=1;i&lt;=500;i++){
        if(eul[s][i]){
        eul[i][s]--;
        eul[s][i]--;
        
        dfs(i);	
        }
    }
    sta.push(s);//将元素s入栈
}


int main(){
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
    	int x;
    	int y;
    	cin&gt;&gt; x &gt;&gt; y;
    	eul[x][y]++;
    	eul[y][x]++;
    	lu[x]++;
    	lu[y]++;
    }
    int num=1;
    for(int i=1;i&lt;=500;i++){
        if(lu[i]%2){
            num=i;
            break;
        }
    }
    dfs(num);
    while(!sta.empty()){//栈是否为空
    	cout &lt;&lt; sta.top()&lt;&lt;endl;//输出栈顶元素
    	sta.pop();//出栈
    }
    	
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集（Disjoint Set Union）]]></title>
        <id>https://ACLYH.github.io/post/bing-cha-ji-disjoint-set-union/</id>
        <link href="https://ACLYH.github.io/post/bing-cha-ji-disjoint-set-union/">
        </link>
        <updated>2020-10-25T08:31:48.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h3 id="1并查集">1.并查集</h3>
<p>在一些有N个元素的集合问题中，我们通常是在开始让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。然而可以知道，这样空间时间复杂度极高，无法通过题目的时限，这个时候，就可以用到并查集来解答。<br>
并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。<br>
<img src="https://img-blog.csdnimg.cn/20190518155257812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2初始化">2.初始化</h3>
<p>初始化很简单，将每个点所在集合初始化为它自己。如有n个点，就将数组fa[i]=i</p>
<pre><code>void init(){
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
	}
}
</code></pre>
<h3 id="3查找">3.查找</h3>
<p>这一步，我们只需要找到根节点，即元素所在的集合。就是当fa[x]等于x时，就找到了根节点，return x。反之，继续查找。</p>
<pre><code>int get(int x){
	if(fa[x]==x) return x;
	return get(fa[x]);
}
</code></pre>
<h3 id="4合并">4.合并</h3>
<p>将两个不同元素所在的集合合并为一个集合。</p>
<pre><code>void merge(int x,int y){
	fa[get(x)] = get(y);
}
</code></pre>
<p>现在，让我们来看看模板的实现</p>
<h3 id="5思路例题">5.思路&amp;例题</h3>
<h4 id="p1551-亲戚">P1551 亲戚</h4>
<p>题目背景</p>
<p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br>
题目描述</p>
<p>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>
输入输出格式<br>
输入格式：</p>
<p>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。</p>
<p>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。</p>
<p>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。</p>
<p>输出格式：</p>
<p>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
<p>输入输出样例<br>
输入样例#1： 复制</p>
<p>6 5 3<br>
1 2<br>
1 5<br>
3 4<br>
5 2<br>
1 3<br>
1 4<br>
2 3<br>
5 6</p>
<p>输出样例#1： 复制</p>
<p>Yes<br>
Yes<br>
No</p>
<p>这道题就可以用并查集来实现。<br>
相当于<br>
<img src="https://img-blog.csdnimg.cn/20190518162322855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
如图，x为y的亲戚，而y又为z的亲戚，所以z为x的亲戚。<br>
然后，就可以搞一波了：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10010;


int n,m,p;
int fa[maxn];

void init(){
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
	}
}
int get(int x){
	if(fa[x]==x) return x;
	return get(fa[x]);
}

void merge(int x,int y){
	fa[get(x)] = get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt; m&gt;&gt;p;
	init();
	int x,y;
	for(int i=1;i&lt;=m;i++){
		cin &gt;&gt; x &gt;&gt; y;
		merge(x,y);
	}
	for(int i=1;i&lt;=p;i++){
		cin &gt;&gt; x &gt;&gt; y;
	    if(get(x)==get(y))cout &lt;&lt; &quot;Yes&quot;&lt;&lt;endl;
		else cout &lt;&lt; &quot;No&quot; &lt;&lt;endl;
	}

	return 0;
}
</code></pre>
<p>但是，不妨想想，这样做会不会太麻烦？<br>
如果z想要知道自己还有没有亲戚，那他就必须问y，才能找到x，这样，会不会耗时间。<br>
再想想，如果有很多亲戚，找起来会不会太慢？<br>
所以，现在看看另一道题</p>
<h4 id="p3367-模板并查集">P3367 【模板】并查集</h4>
<p>题目描述</p>
<p>如题，现在有一个并查集，你需要完成合并和查询操作。<br>
输入输出格式<br>
输入格式：</p>
<p>第一行包含两个整数N、M，表示共有N个元素和M个操作。</p>
<p>接下来M行，每行包含三个整数Zi、Xi、Yi</p>
<p>当Zi=1时，将Xi与Yi所在的集合合并</p>
<p>当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N</p>
<p>输出格式：</p>
<p>如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N</p>
<p>输入输出样例<br>
输入样例#1：</p>
<p>4 7<br>
2 1 2<br>
1 1 2<br>
2 1 2<br>
1 3 4<br>
2 1 4<br>
1 2 3<br>
2 1 4</p>
<p>输出样例#1：</p>
<p>N<br>
Y<br>
N<br>
Y</p>
<p>说明</p>
<p>时空限制：1000ms,128M</p>
<p>数据规模：</p>
<p>对于30%的数据，N&lt;=10，M&lt;=20；</p>
<p>对于70%的数据，N&lt;=100，M&lt;=1000；</p>
<p>对于100%的数据，N&lt;=10000，M&lt;=200000。</p>
<p>这倒就要用到路径压缩。<br>
如何压缩？<br>
简单来说就是将原本的子孙节点全部直接连到根节点上。<br>
<img src="https://img-blog.csdnimg.cn/20190531200520930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
让它们直接找到x，就行了。<br>
所以，只需要改一改</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10010;


int n,m;
int fa[maxn];

void init(){
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
	}
}
int get(int x){
	if(fa[x]==x) return x;
	return fa[x]=get(fa[x]);
}

void merge(int x,int y){
	fa[get(x)] = get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt; m;
	init();
	int x,y,z;
	for(int i=1;i&lt;=m;i++){
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
		if(x==1){
		merge(y,z);
	    }else if(get(y)==get(z))cout &lt;&lt; &quot;Y&quot;&lt;&lt;endl;
		else cout &lt;&lt; &quot;N&quot; &lt;&lt;endl;
	}

	return 0;
}
</code></pre>
<h4 id="各种各样的并查集">各种各样的并查集</h4>
<h5 id="网络交友">网络交友</h5>
<p>Description</p>
<p>在网络社交的过程中，通过朋友，也能认识新的朋友。在某个朋友关系图中，假定 A 和 B 是朋友，B 和 C 是朋友，那么 A 和 C 也会成为朋友。即，我们规定朋友的朋友也是朋友。</p>
<p>现在要求你每当有一对新的朋友认识的时候，你需要计算两人的朋友圈合并以后的大小。</p>
<p>Input</p>
<p>第一行：一个整数 n(n≤5000)n(n\leq 5000)n(n≤5000)，表示有 nnn 对朋友认识。</p>
<p>接下来 nnn 行：每行输入两个名字。表示新认识的两人的名字，用空格隔开。（名字是一个首字母大写后面全是小写字母且长度不超过 20 的串）。</p>
<p>Output</p>
<p>对于每一对新认识的朋友，输出合并以后的朋友圈的大小。</p>
<p>Sample Input 1</p>
<p>3<br>
Fred Barney<br>
Barney Betty<br>
Betty Wilma</p>
<p>Sample Output 1</p>
<p>2<br>
3<br>
4</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10010;
int n,k;
int sz[maxn],fa[maxn];

map&lt;string, int&gt;mp;

void init(){
	for(int i=1;i&lt;=n+1;i++){
		fa[i]=i;
		sz[i]=1;
	}
}

int get(int x){
	if(fa[x]==x) return x;
	else return fa[x]=get(fa[x]);
}

void merge(int x,int y){
	int tx=get(x);
	int ty=get(y);
	if(tx!=ty){
		fa[tx]=ty;
        sz[ty]+=sz[tx];
	}
}

int main(){
	cin &gt;&gt; n;
	int ans=0;
	init();
	string s1,s2;
	while(n--){
		cin &gt;&gt; s1 &gt;&gt; s2;
		int x,y;
		if((x=mp[s1]) == 0) x = mp[s1] = ++k;
		if((y=mp[s2]) == 0) y = mp[s2] = ++k;
		merge(x,y);
		cout &lt;&lt; sz[get(y)] &lt;&lt; endl;
			}
	
	return 0;
}
</code></pre>
<h5 id="昆虫的生活">昆虫的生活</h5>
<p>Description</p>
<p>一天蒜头君正在研究一种稀有昆虫的行为。他们具有两种不同的性别，他假设他们只与异性昆虫互动。因为他们背上都印有数字，所以他们之间的一起互动，在实验室是很容易识别的。</p>
<p>现在给出一些昆虫之间的互动，看看实验是否支持蒜头君的假设--只有异性互动。</p>
<p>Input</p>
<p>第一行输入两个整数 nnn (1≤n≤2000)(1 \le n \le 2000)(1≤n≤2000) ， mmm (1≤m≤106)(1 \le m \le 10^6)(1≤m≤106)。其中 nnn 表示昆虫的数目，mmm 表示昆虫互动的关系数量。</p>
<p>接下来会有 mmm 行，每行有两个整数 xxx ， yyy (1≤x,y≤n)(1 \le x,y \le n)(1≤x,y≤n)。表示昆虫 xxx 和昆虫 yyy 之间有过互动。</p>
<p>Output</p>
<p>判断蒜头君的假设是否正确，如果正确请输入yes，否则输出no。</p>
<p>Sample Input 1</p>
<p>3 3<br>
1 2<br>
2 3<br>
1 3</p>
<p>Sample Output 1</p>
<p>no</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=5010;

struct node{
	int x,y;
}g[10000010];

int fa[maxn*2];
int n,m;
int init(){
	for(int i=1;i&lt;=n*2;i++){
		fa[i]=i;
	}
}

int get(int x){
	if(fa[x]==x)return x;
	int r=get(fa[x]);
	fa[x]=r;
	return r;
}

void merge(int x,int y){
	fa[get(x)]=get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt;m;
	init();
	for(int i=1;i&lt;=m;i++){
		cin &gt;&gt; g[i].x  &gt;&gt; g[i].y;
	}
	for(int i=1;i&lt;=m;i++){
		if(get(g[i].x)==get(g[i].y)) {
		cout &lt;&lt;&quot;no&quot;&lt;&lt;endl;
		return 0;
	}
		merge(g[i].x,g[i].y+n);
		merge(g[i].y,g[i].x+n);
	}
	cout &lt;&lt;&quot;yes&quot;;
	return 0;
}
</code></pre>
<h5 id="关押罪犯">关押罪犯</h5>
<p>Description</p>
<p>S 城现有两座监狱，一共关押着 NNN 名罪犯，编号分别为 111 ~ NNN。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用 “怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 ccc 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 ccc 的冲突事件。</p>
<p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p>
<p>在详细考察了 NNN 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p>
<p>那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p>
<p>Input</p>
<p>输入第一行为两个正整数 N(1≤N≤20000)和 M(1≤M≤100000)，分别表示罪犯的数目以及存在仇恨的罪犯对数。</p>
<p>接下来的 M 行每行为三个正整数 aj,bj,a_j,b_j，表示 a_j​ 号和 b_j​ 号罪犯之间存在仇恨，其怨气值为 c_j​。数据保证 1&lt;aj,bj≤N1&lt;a_j, b_j \le N1&lt;aj​,bj​≤N，0&lt;cj≤1090 &lt; c_j \le 10^90&lt;cj​≤109，且每对罪犯组合只出现一次。</p>
<p>Output</p>
<p>输出共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 000。</p>
<p>Sample Input 1</p>
<p>4 6<br>
1 4 2534<br>
2 3 3512<br>
1 2 28351<br>
1 3 6618<br>
2 4 1805<br>
3 4 12884</p>
<p>Sample Output 1</p>
<p>3512</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 200100;
const int maxm = 100100;
struct node{
	int u,v;
	int s;
}e[maxm];

bool cmp(node a,node b){
	return a.s&gt;b.s;
}

int fa[maxn*2];
int n,m;
void init(){
	for(int i=1;i&lt;=2*n;i++){
		fa[i] = i;
	}
}

int get(int x){
	if(fa[x]!=x) fa[x]=get(fa[x]);
	return fa[x];
}

void merge(int x,int y)
{
    fa[get(x)] = get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt; m;
		init();
    	for(int i=1;i&lt;=m;i++){
    		cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].s;
		}
	sort(e+1,e+m+1,cmp);

for(int i=1;i&lt;=m;i++){
	if(get(e[i].u)==get(e[i].v)){
	   
		cout &lt;&lt; e[i].s;
		return 0;
	}else{
		merge(e[i].u,e[i].v+n);
		merge(e[i].u+n,e[i].v);
		
    } 
}
	cout &lt;&lt; &quot;0&quot;;
	return 0;
}
</code></pre>
<h5 id="接龙">接龙</h5>
<p><a href="http://120.77.248.79/problem/3033102">传送门</a></p>
<p>前缀差分思想，维护每个纸牌前面到底有多少纸牌的特性。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=50100;
int n,m;
int fa[N];
int size[N],dist[N];

void init(){
    for(int i=0;i&lt;N;i++){
        fa[i]=i;
        size[i]=1;
        dist[i]=0;
    }
}

int get(int x){
    if(fa[x]==x){
        return x;
    }
    int y=fa[x];
    fa[x]=get(y);
    dist[x]+=dist[y];
    return fa[x];
}

void merge(int x,int y){
    x=get(x);
    y=get(y);
    if(x!=y){
        fa[x]=y;
        dist[x]=size[y];
        size[y]+=size[x];
    }
}
int main(){
	
    init();
    int n;
    cin&gt;&gt;n;
    
    while(n--){
        char op;
        int x,y;
        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
        if(op=='M'){
            merge(x,y);
        }else{
            if(get(x)==get(y)){
                cout&lt;&lt;fabs(dist[x]-dist[y])-1&lt;&lt;endl;
            }else{
                cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单调队列]]></title>
        <id>https://ACLYH.github.io/post/dan-diao-dui-lie/</id>
        <link href="https://ACLYH.github.io/post/dan-diao-dui-lie/">
        </link>
        <updated>2020-06-06T04:03:59.000Z</updated>
        <content type="html"><![CDATA[<h4 id="单调队列的性质"><strong>单调队列的性质</strong></h4>
<p>单调就是指一直增或一直减，例如1，2，3，4就是单调增，4，3，2，1就是单调减。而单调队列就有这种性质。<br>
所以，单调队列具有单调性以及队列的性质。</p>
<h4 id="操作方式"><strong>操作方式</strong></h4>
<p>数据结构队列是先进先出，相当于数列3,7,5,9,现在有一个数2要进队，那么，按队列的操作应该将数列变为7,5,9,2。</p>
<p>然而单调队列就不一样。假设有一条队列7,6,3,4，现在又有一个数5要进队，却看见3，4都比5要弱~~（类似MYJ在某STARLbast中将LYH打爆的行为）~~，所以就有了一种类似插队的方法，5将3和4挤掉，来到了6的后面，构成了这种队列：<br>
<img src="https://i.loli.net/2019/08/12/QXpNaTmjAouB4sD.png" alt="此处输入图片的描述" loading="lazy"></p>
<p>所以单调队列维护单调性就是通过插队把队尾破坏了单调的数全部从队尾退队，使队列元素维持单调（单调队列与队列不同就是单调队列既可以从队首出队，也可以从队尾出队）。<br>
看看一道模板<s>水</s>题<br>
<a href="https://www.luogu.org/problem/P1886">P1886 滑动窗口</a><br>
<s>据说可以用线段树，树状数组什么的，但单调队列是拯救蒟蒻的做法(逃</s></p>
<p>所以说，这道题到底怎么做？<br>
其实只需要枚举所有的连续子序列，使用单调队列找出最大值。<br>
开始<s>乱搞</s>写代码：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,k;
int a[1000001]={0},q[10000001]={0};q数组表示单调队列，a表示其所对应的在原列表里的下标
int head=1;//头指针
int tail=1;//队尾指针
int main(){
	cin &gt;&gt; n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i];
	}
	for(int i=1;i&lt;=n;i++){
		while(head&lt;tail&amp;&amp;a[q[tail-1]]&gt;a[i]){
			tail--;//插队，将后面的数踢掉，以维护单调性
		}
		q[tail++]=i;//存编号
        while(head&lt;tail&amp;&amp;q[head]&lt;=i-k){
        	head++;//队首元素太old了，就出队。
		}
        if(i&gt;=k){
        	cout &lt;&lt;a[q[head]]&lt;&lt; &quot; &quot;;//按题目要求的输出
		}
	}
	cout &lt;&lt; endl;
	--------------------------------------------------------------------------------------------
	head=1,tail=1;

	for(int i=1;i&lt;=n;i++){
		while(head&lt;tail&amp;&amp;a[q[tail-1]]&lt;a[i]){//队列中存在元素，又队尾元素比下一个处理的值大，即表示队尾元素太old，就让队尾元素出队。当队尾元素小于下一个处理值，单调性成立。
			tail--;
		}
		q[tail++]=i;//存编号
        while(head&lt;tail&amp;&amp;q[head]&lt;=i-k){
        	head++;//队首元素太old了，就出队。
		}
        if(i&gt;=k){
        	cout &lt;&lt; a[q[head]] &lt;&lt; &quot; &quot;;//cout队首元素，即最大值
		}
	}
	cout &lt;&lt; endl;
	return 0;
	//实际上分割线上下代码都差不多，只是维护单调性的while循环不一样
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初涉优先队列]]></title>
        <id>https://ACLYH.github.io/post/youxian/</id>
        <link href="https://ACLYH.github.io/post/youxian/">
        </link>
        <updated>2020-06-06T03:31:49.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>优先队列，是，一个跟单调队列一样神奇的数据结构。<br>
手写优先队列不会，只能用STL库自带的priority_queue。</p>
<h2 id="声明priority_queue的头文件">声明priority_queue的头文件</h2>
<pre><code>#include&lt;queue&gt;或#include&lt;bits/stdc++.h&gt;
</code></pre>
<h2 id="定义">定义</h2>
<pre><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; a; //less&lt;int&gt;递增函数
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;//depue双端队列，greater&lt;int&gt;递减函数
priority_queue&lt;int&gt;a;
priority_queue&lt;double&gt;a;
---------------------------------------------------
struct node{
~~~~~
}
priority_queue&lt;node&gt;a;
--------------------------------------------------
</code></pre>
<h2 id="priority_queue的操作">priority_queue的操作</h2>
<p>实际上就是那些：</p>
<pre><code>priority_queue&lt;int&gt;q;
q.empty()——队列是否为空，空为true，否则为false
q.pop()——删除队顶元素
q.push()——压入一个元素
q.size()——返回优先队列中的元素个数
q.top()——返回q的第一个元素
</code></pre>
<h2 id="priority_queue的排序方式">priority_queue的排序方式</h2>
<pre><code>priority_queue&lt;int&gt; q;//优先队列自带排序，元素从大到小的顺序排序出队
priority_queue&lt;int,vector&lt;int&gt;, greater&lt;int&gt; &gt; q;//greater&lt;int&gt;，按照元素从小到大的顺序排序出队
struct cmp{
	int x,y;
	bool operator&lt; (const node &amp; a)const{
		return x&lt;a.x;
	}
};//自定义结构体，重载&lt;；

priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; a;//less排序从大到小
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a; //greater排序从小到大
//less和greater后的两个&gt;之间要打&quot; &quot;，不然错哪里都不知道~~（绝对没有体验过）~~

</code></pre>
<p>所以，优先队列实际上就是一个自带从大到小排序的队列，最大元素会排在队首，然后，跟队列一样先进先出~~（感觉比单调队列半路插队要好写一些？）~~<br>
那就做一道例题吧~~（绝对没有滑动窗口的普及+/提高）~~<br>
<a href="https://www.luogu.org/problem/P3887">P3887 [GDOI2014]世界杯</a><br>
读题可知，这道题有四个综合水平值，说明了什么？<br>
当然是开四个优先队列啦~~（逃~~</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

priority_queue&lt;int,vector&lt;int&gt;, less&lt;int&gt; &gt; k,d,m,f;//根据题目开的四个优先队列，也可以打四次priority_queue&lt;int,vector&lt;int&gt;, less&lt;int&gt; &gt;，不然考试背不到priority_queue就完了
int q;
int a,b,c,e;//守门员、后卫、中场和前锋供挑选的球员人数
int main(){
	int cnt;//存储
	cin &gt;&gt; a&gt;&gt;b&gt;&gt;c&gt;&gt;e;
	for(int i=1;i&lt;=a;i++){
		cin &gt;&gt; cnt;
		f.push(cnt);
	}
	for(int i=1;i&lt;=b;i++){
		cin &gt;&gt; cnt;
		m.push(cnt);
	}
	for(int i=1;i&lt;=c;i++){
		cin &gt;&gt; cnt;
		d.push(cnt);
	}
	for(int i=1;i&lt;=e;i++){
		cin &gt;&gt; cnt;
		k.push(cnt); 
	}//守门员、后卫、中场和前锋的能力值，分push进自己优先队列
	cin &gt;&gt;q;
	int x,y,z;
	
	for(int i=1;i&lt;=q;i++){//对综合水平值的计算
		int ans=0;//ans放外面的值就不会清零了，所以放在for内
		cin &gt;&gt; x &gt;&gt; y &gt;&gt;z;
		while(z--){
			int cnt=k.top();
			k.pop();
			ans+=cnt;
		}//出队，当前总能力值+上cnt 
		while(y--){
			int cnt=d.top();
			d.pop();
			ans+=cnt;
		}同上
		while(x--){
			int cnt=m.top();
			m.pop();
			ans+=cnt;
		}同上
		ans+=f.top();
		f.pop();题目所说不把守门员计算在内，单独处理
		printf(&quot;%.2lf\n&quot;,ans*1.0/11);//关于输出两位数的处理
	}
	

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello world]]></title>
        <id>https://ACLYH.github.io/post/hello-world/</id>
        <link href="https://ACLYH.github.io/post/hello-world/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    cout &lt;&lt; &quot;Hello world&quot;&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="about-me">About me</h2>
<p>一个<strong>CQ</strong>的蒟蒻OIer</p>
]]></content>
    </entry>
</feed>