<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ACLYH.github.io</id>
    <title>LYHのblog</title>
    <updated>2020-10-25T06:09:21.287Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ACLYH.github.io"/>
    <link rel="self" href="https://ACLYH.github.io/atom.xml"/>
    <subtitle>IOI AK me</subtitle>
    <logo>https://ACLYH.github.io/images/avatar.png</logo>
    <icon>https://ACLYH.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, LYHのblog</rights>
    <entry>
        <title type="html"><![CDATA[单调队列]]></title>
        <id>https://ACLYH.github.io/post/dan-diao-dui-lie/</id>
        <link href="https://ACLYH.github.io/post/dan-diao-dui-lie/">
        </link>
        <updated>2020-06-06T04:03:59.000Z</updated>
        <content type="html"><![CDATA[<h4 id="单调队列的性质"><strong>单调队列的性质</strong></h4>
<p>单调就是指一直增或一直减，例如1，2，3，4就是单调增，4，3，2，1就是单调减。而单调队列就有这种性质。<br>
所以，单调队列具有单调性以及队列的性质。</p>
<h4 id="操作方式"><strong>操作方式</strong></h4>
<p>数据结构队列是先进先出，相当于数列3,7,5,9,现在有一个数2要进队，那么，按队列的操作应该将数列变为7,5,9,2。</p>
<p>然而单调队列就不一样。假设有一条队列7,6,3,4，现在又有一个数5要进队，却看见3，4都比5要弱~~（类似MYJ在某STARLbast中将LYH打爆的行为）~~，所以就有了一种类似插队的方法，5将3和4挤掉，来到了6的后面，构成了这种队列：<br>
<img src="https://i.loli.net/2019/08/12/QXpNaTmjAouB4sD.png" alt="此处输入图片的描述" loading="lazy"></p>
<p>所以单调队列维护单调性就是通过插队把队尾破坏了单调的数全部从队尾退队，使队列元素维持单调（单调队列与队列不同就是单调队列既可以从队首出队，也可以从队尾出队）。<br>
看看一道模板<s>水</s>题<br>
<a href="https://www.luogu.org/problem/P1886">P1886 滑动窗口</a><br>
<s>据说可以用线段树，树状数组什么的，但单调队列是拯救蒟蒻的做法(逃</s></p>
<p>所以说，这道题到底怎么做？<br>
其实只需要枚举所有的连续子序列，使用单调队列找出最大值。<br>
开始<s>乱搞</s>写代码：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,k;
int a[1000001]={0},q[10000001]={0};q数组表示单调队列，a表示其所对应的在原列表里的下标
int head=1;//头指针
int tail=1;//队尾指针
int main(){
	cin &gt;&gt; n&gt;&gt;k;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;a[i];
	}
	for(int i=1;i&lt;=n;i++){
		while(head&lt;tail&amp;&amp;a[q[tail-1]]&gt;a[i]){
			tail--;//插队，将后面的数踢掉，以维护单调性
		}
		q[tail++]=i;//存编号
        while(head&lt;tail&amp;&amp;q[head]&lt;=i-k){
        	head++;//队首元素太old了，就出队。
		}
        if(i&gt;=k){
        	cout &lt;&lt;a[q[head]]&lt;&lt; &quot; &quot;;//按题目要求的输出
		}
	}
	cout &lt;&lt; endl;
	--------------------------------------------------------------------------------------------
	head=1,tail=1;

	for(int i=1;i&lt;=n;i++){
		while(head&lt;tail&amp;&amp;a[q[tail-1]]&lt;a[i]){//队列中存在元素，又队尾元素比下一个处理的值大，即表示队尾元素太old，就让队尾元素出队。当队尾元素小于下一个处理值，单调性成立。
			tail--;
		}
		q[tail++]=i;//存编号
        while(head&lt;tail&amp;&amp;q[head]&lt;=i-k){
        	head++;//队首元素太old了，就出队。
		}
        if(i&gt;=k){
        	cout &lt;&lt; a[q[head]] &lt;&lt; &quot; &quot;;//cout队首元素，即最大值
		}
	}
	cout &lt;&lt; endl;
	return 0;
	//实际上分割线上下代码都差不多，只是维护单调性的while循环不一样
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初涉优先队列]]></title>
        <id>https://ACLYH.github.io/post/youxian/</id>
        <link href="https://ACLYH.github.io/post/youxian/">
        </link>
        <updated>2020-06-06T03:31:49.000Z</updated>
        <content type="html"><![CDATA[<hr>
<p>优先队列，是，一个跟单调队列一样神奇的数据结构。<br>
手写优先队列不会，只能用STL库自带的priority_queue。</p>
<h2 id="声明priority_queue的头文件">声明priority_queue的头文件</h2>
<pre><code>#include&lt;queue&gt;或#include&lt;bits/stdc++.h&gt;
</code></pre>
<h2 id="定义">定义</h2>
<pre><code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt; a; //less&lt;int&gt;递增函数
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;//depue双端队列，greater&lt;int&gt;递减函数
priority_queue&lt;int&gt;a;
priority_queue&lt;double&gt;a;
---------------------------------------------------
struct node{
~~~~~
}
priority_queue&lt;node&gt;a;
--------------------------------------------------
</code></pre>
<h2 id="priority_queue的操作">priority_queue的操作</h2>
<p>实际上就是那些：</p>
<pre><code>priority_queue&lt;int&gt;q;
q.empty()——队列是否为空，空为true，否则为false
q.pop()——删除队顶元素
q.push()——压入一个元素
q.size()——返回优先队列中的元素个数
q.top()——返回q的第一个元素
</code></pre>
<h2 id="priority_queue的排序方式">priority_queue的排序方式</h2>
<pre><code>priority_queue&lt;int&gt; q;//优先队列自带排序，元素从大到小的顺序排序出队
priority_queue&lt;int,vector&lt;int&gt;, greater&lt;int&gt; &gt; q;//greater&lt;int&gt;，按照元素从小到大的顺序排序出队
struct cmp{
	int x,y;
	bool operator&lt; (const node &amp; a)const{
		return x&lt;a.x;
	}
};//自定义结构体，重载&lt;；

priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; a;//less排序从大到小
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;a; //greater排序从小到大
//less和greater后的两个&gt;之间要打&quot; &quot;，不然错哪里都不知道~~（绝对没有体验过）~~

</code></pre>
<p>所以，优先队列实际上就是一个自带从大到小排序的队列，最大元素会排在队首，然后，跟队列一样先进先出~~（感觉比单调队列半路插队要好写一些？）~~<br>
那就做一道例题吧~~（绝对没有滑动窗口的普及+/提高）~~<br>
<a href="https://www.luogu.org/problem/P3887">P3887 [GDOI2014]世界杯</a><br>
读题可知，这道题有四个综合水平值，说明了什么？<br>
当然是开四个优先队列啦~~（逃~~</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

priority_queue&lt;int,vector&lt;int&gt;, less&lt;int&gt; &gt; k,d,m,f;//根据题目开的四个优先队列，也可以打四次priority_queue&lt;int,vector&lt;int&gt;, less&lt;int&gt; &gt;，不然考试背不到priority_queue就完了
int q;
int a,b,c,e;//守门员、后卫、中场和前锋供挑选的球员人数
int main(){
	int cnt;//存储
	cin &gt;&gt; a&gt;&gt;b&gt;&gt;c&gt;&gt;e;
	for(int i=1;i&lt;=a;i++){
		cin &gt;&gt; cnt;
		f.push(cnt);
	}
	for(int i=1;i&lt;=b;i++){
		cin &gt;&gt; cnt;
		m.push(cnt);
	}
	for(int i=1;i&lt;=c;i++){
		cin &gt;&gt; cnt;
		d.push(cnt);
	}
	for(int i=1;i&lt;=e;i++){
		cin &gt;&gt; cnt;
		k.push(cnt); 
	}//守门员、后卫、中场和前锋的能力值，分push进自己优先队列
	cin &gt;&gt;q;
	int x,y,z;
	
	for(int i=1;i&lt;=q;i++){//对综合水平值的计算
		int ans=0;//ans放外面的值就不会清零了，所以放在for内
		cin &gt;&gt; x &gt;&gt; y &gt;&gt;z;
		while(z--){
			int cnt=k.top();
			k.pop();
			ans+=cnt;
		}//出队，当前总能力值+上cnt 
		while(y--){
			int cnt=d.top();
			d.pop();
			ans+=cnt;
		}同上
		while(x--){
			int cnt=m.top();
			m.pop();
			ans+=cnt;
		}同上
		ans+=f.top();
		f.pop();题目所说不把守门员计算在内，单独处理
		printf(&quot;%.2lf\n&quot;,ans*1.0/11);//关于输出两位数的处理
	}
	

	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello world]]></title>
        <id>https://ACLYH.github.io/post/hello-world/</id>
        <link href="https://ACLYH.github.io/post/hello-world/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <content type="html"><![CDATA[<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    cout &lt;&lt; &quot;Hello world&quot;&lt;&lt;endl;
    return 0;
}
</code></pre>
<h2 id="about-me">About me</h2>
<p>一个<strong>CQ</strong>的蒟蒻OIer</p>
]]></content>
    </entry>
</feed>