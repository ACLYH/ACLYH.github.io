<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://ACLYH.github.io</id>
    <title>Lanthanum</title>
    <updated>2020-10-28T13:41:55.166Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://ACLYH.github.io"/>
    <link rel="self" href="https://ACLYH.github.io/atom.xml"/>
    <subtitle>心之所向，素履以往，生如逆旅，一苇以航。</subtitle>
    <logo>https://ACLYH.github.io/images/avatar.png</logo>
    <icon>https://ACLYH.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Lanthanum</rights>
    <entry>
        <title type="html"><![CDATA[最小生成树模板]]></title>
        <id>https://ACLYH.github.io/post/zui-xiao-sheng-cheng-shu-mo-ban/</id>
        <link href="https://ACLYH.github.io/post/zui-xiao-sheng-cheng-shu-mo-ban/">
        </link>
        <updated>2020-10-28T13:39:00.000Z</updated>
        <summary type="html"><![CDATA[<p>题目描述</p>
<p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz</p>
]]></summary>
        <content type="html"><![CDATA[<p>题目描述</p>
<p>如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz</p>
<!-- more -->
<p>输入输出格式<br>
输入格式：</p>
<p>第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&lt;=5000，M&lt;=200000）</p>
<p>接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi</p>
<p>输出格式：</p>
<p>输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz</p>
<p>输入输出样例<br>
输入样例#1：</p>
<p>4 5<br>
1 2 2<br>
1 3 2<br>
1 4 3<br>
2 3 4<br>
3 4 3</p>
<p>输出样例#1：</p>
<p>7</p>
<p>数据规模：</p>
<p>对于20%的数据：N&lt;=5，M&lt;=20</p>
<p>对于40%的数据：N&lt;=50，M&lt;=2500</p>
<p>对于70%的数据：N&lt;=500，M&lt;=10000</p>
<p>对于100%的数据：N&lt;=5000，M&lt;=200000</p>
<p>样例解释：<br>
<img src="https://img-blog.csdnimg.cn/20190609135251535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
所以最小生成树的总边权为2+2+3=7</p>
<p>并查集<br>
既然最小，那么重载cmp函数。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,m;
struct node{
    int u;
    int w;
    int v;
}g[1110000];
bool cmp(node a,node b){
    return a.w&lt;b.w;
}
int fa[10010];
void init(){
    for(int i=1;i&lt;=n;i++){
        fa[i]=i;
    }
}
int get(int x){
    if(fa[x]==x){
        return x;
    }else{
        int y=get(fa[x]);
        fa[x]=y;
        return y;
    }
}
int main(){
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=m;i++){
        cin&gt;&gt;g[i].u&gt;&gt;g[i].v&gt;&gt;g[i].w;
    }
    init();
    sort(g+1,g+1+m,cmp);
    int ans=0;
    for(int i=1;i&lt;=m;i++){
        if(get(g[i].u)!=get(g[i].v)){
            ans+=g[i].w;
            fa[get(g[i].u)]=get(g[i].v);
        }
    }
    cout&lt;&lt;ans;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路（单源）]]></title>
        <id>https://ACLYH.github.io/post/zui-duan-lu-dan-yuan/</id>
        <link href="https://ACLYH.github.io/post/zui-duan-lu-dan-yuan/">
        </link>
        <updated>2020-10-28T13:36:36.000Z</updated>
        <summary type="html"><![CDATA[<p>Dijkstra算法和SPFA算法用于求单源最短路。<br>
最短路就是求两点之间的最短路径。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Dijkstra算法和SPFA算法用于求单源最短路。<br>
最短路就是求两点之间的最短路径。</p>
<!-- more -->
<p>最短路径怎么求呢？<br>
更新就是了（松弛）。<br>
<img src="https://img-blog.csdnimg.cn/20190419201104445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">先赋予厚望（先假设无穷大）<br>
<img src="https://img-blog.csdnimg.cn/20190419201303886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">然后依次更新<br>
<img src="https://img-blog.csdnimg.cn/20190419202104933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
通过起点1来比较哪条路到终点20最短</p>
<p><img src="https://img-blog.csdnimg.cn/20190419202225404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy">暂时选择这条绿色的路<br>
继续比较<br>
<img src="https://img-blog.csdnimg.cn/20190419202710202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
所以蓝色的路是最短的。<br>
然后看一道纯模板题。</p>
<pre><code>骑车比赛

Description

小信准备去参加骑车比赛，比赛在 n 个城市间进行，编号从 1 到 n。选手们都从城市 1 出发，终点在城市 n。

已知城市间有 m 条道路，每条道路连接两个城市，注意道路是双向的。现在小信知道了他经过每条道路需要花费的时间，他想请你帮他计算一下，他这次比赛最少需要花多少时间完成。

Input

第一行输入两个整数 n,m（1≤n≤1,000,1≤m≤5,000），分别代表城市个数和道路总数。接下来输入 m 行，每行输入三个数字 a,b,c（1≤a,b≤n,1≤c≤200），分别代表道路的起点和道路的终点，以及小信骑车通过这条道路需要花费的时间。保证输入的图是连通的。

Output

输出一行，输出一个整数，输出小信完成比赛需要的最少时间。

Sample Input 1

5 6
1 2 2
2 3 3
2 5 5
3 4 2
3 5 1
4 5 1

Sample Output 1

6


</code></pre>
<p>典型的最短路<br>
Dijkstra模板：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;


int n,m;

struct node{//结构体
	int v,w;
	node(){ };
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
int dst[10100];

void add(int u,int v,int w){//建图
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){
	memset(dst,0x3f,sizeof dst);
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			int w = g[u][j].w;
			dst[v] = min(dst[v],dst[u]+w);
			
		}
		
		int mi=0x3f3f3f3f;//无穷大
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v,w;
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	
	dij(1);
	cout &lt;&lt; dst[n];
	
	return 0;
}
</code></pre>
<p>SPFA模板</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=1010;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
int inq[maxn];

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}

void spfa(int s){
	memset(dst,inf,sizeof dst);
	int u=s;
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	int u , v , w; 
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	spfa(1);
	cout &lt;&lt; dst[n]&lt;&lt;endl;
	return 0;
}
</code></pre>
<pre><code>迷阵突围

Description

小信陷入了坐标系上的一个迷阵，迷阵上有 n个点，编号从 1 到 n。小信在编号为 1 的位置，他想到编号为 n 的位置上。小信当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在小信知道了 n 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

注意，每条路径上不能重复经过同一个点。

Input

第一行输入两个整数 n (1≤n≤200) 和 m，表示一共有 n 个点和 m 条边。

接下来输入 n 行，每行输入两个整数 xi,yi (−500≤xi,yi≤500)，代表第 i 个点的坐标。

接下来输入 m 行，每行输入两个整数 pj,qj (1≤pj,qj≤n)，表示点 pj 和点 qj 之间相连。

Output

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 -1。

Sample Input 1

3 3
1 1
2 2
3 2
1 2
2 3
1 3

Sample Output 1

2.41


</code></pre>
<p>模板改进。（两个dij函数）</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,m;

struct node{
	int v;
	double w;
	node(){ };
	node(int _v,double _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
double dst[10100];

int x[10100],y[10100];
int pre[10100];
void add(int u,int v,double w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){

	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				pre[v]=u;
			}
		}
		
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}

}


void dij2(int s,int uu,int vv){
	
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(uu ==u &amp;&amp; vv==v || uu==v &amp;&amp; vv == u){
				continue;
			}
	
			dst[v] = min(dst[v],dst[u]+w);

	}
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	 
	}

}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v;
	double w;
	
	for(int i=1;i&lt;=n;i++){
		cin &gt;&gt; x[i] &gt;&gt;y[i];
	}
	
	while (m--){
		cin &gt;&gt; u &gt;&gt; v;
		w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
		add(u,v,w);
	}
	
	dij(1);

	
	double mi=1e20;
	for(int i=n;pre[i]!=0;i=pre[i]){
		dij2(1,i,pre[i]);
		mi=min(mi,dst[n]);
	}
	     if(mi == 1e20){
	      cout &lt;&lt; &quot;-1&quot;&lt;&lt;endl;
		 }else{
			 cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mi&lt;&lt;endl;
		}
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找法]]></title>
        <id>https://ACLYH.github.io/post/er-fen-cha-zhao-fa/</id>
        <link href="https://ACLYH.github.io/post/er-fen-cha-zhao-fa/">
        </link>
        <updated>2020-10-28T13:25:50.000Z</updated>
        <summary type="html"><![CDATA[<p>二分查找法是从区间[i，j]上连续不断将sum（a）·sum（b）&lt;0的函数ans=sum（x），通过循环实现把函数sum（x）的0点所在区间一分为二，如此循环，使区间[i,j]的两个端点逐渐像0点靠近，得到0点近似值的方法。可以实现空间优化，适用于数据较大的题目。时间复杂第O（log（2n））。</p>
]]></summary>
        <content type="html"><![CDATA[<p>二分查找法是从区间[i，j]上连续不断将sum（a）·sum（b）&lt;0的函数ans=sum（x），通过循环实现把函数sum（x）的0点所在区间一分为二，如此循环，使区间[i,j]的两个端点逐渐像0点靠近，得到0点近似值的方法。可以实现空间优化，适用于数据较大的题目。时间复杂第O（log（2n））。</p>
<!-- more -->
<p>在使用c++的二分查找法，要先将数据排序，二分查找法的基本思想可以这样总结：我们设数据是按升序排序的，根据题目中的数a，从序列的中间进行二分，如果当前i位置值等于a，则停止查找 ；假如a小于当前位置i，则在数列的前部分中查找；若a大于当前位置i，就在数列的后段进行查找，如果还没找到，再次二分，直到找到了a值。</p>
<p>二分例题：</p>
<p>小信的猜想<br>
Description<br>
有一天小信突发奇想，他有一个猜想，任意一个大于 2 的偶数好像总能写成 2 个质数的和。小信查了资料，发现这个猜想很早就被一个叫哥德巴赫的人提出来了，称为哥德巴赫猜想。目前还没有证明这个猜想的正确性。小信告诉你一个整数 n ，让你用这个数去验证。注意 1 不是质数。</p>
<p>Input</p>
<p>输入一个偶数 n(2&lt;n≤8000000)。</p>
<p>Output</p>
<p>输出一个整数表示有多少对 (x,y) 满足 x+y=n(x≤y) 且 x,y 均为质数。</p>
<p>Sample Input 1<br>
6<br>
Sample Output 1<br>
1<br>
Sample Input 2<br>
10<br>
Sample Output 2<br>
2<br>
——摘自YCOJ<br>
对，是一道哥德巴赫猜想。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[9000000];
bool b[9000000];
int main(){
	int n,cnt=0,k=0;
	cin &gt;&gt; n;
	for(int i=2;i&lt;n;i++){
		if(b[i]==0){
		 for(int j=i+i;j&lt;n;j+=i){
			b[j]=1;
		}
		a[k]=i;
		k++;
	}
}
	for(int i=0;i&lt;k;i++){
			//查找 
			int tmp = n-a[i];
			
			int l=i,r=k-1,mid;
			while(r-l&gt;1){
				mid=(l+r)/2;
				if(a[mid]&lt;tmp){
					l=mid+1;
				}else{
					r=mid;
				}
			}
			if(a[l] == tmp || a[r]==tmp){
				cnt++;
			}
		}
	cout &lt;&lt; cnt;
	return 0;
}
</code></pre>
<p>这道题就运用到了二分查找法，正片程序可以看做两部分，一边是主程序，一边是二分查找法的实现，用<code>while(r-l&gt;1)</code>比较并循环，判断数据是在上半部分还是下半部分，再用<code>mid=(l+r)/2;</code>进行折半查找。</p>
<h4 id="查找">查找</h4>
<p>Description</p>
<p>给出一个有 n 个元素的数列 a 和两个整数 k 和 s，其中数列 a 的元素是按照升序排列的。</p>
<p>请你在数列中找出一个元素 x，使得的 x+k=s。</p>
<p>Input</p>
<p>输入第一行一个整数 n(1≤n≤10^5)，表示数列中的元素个数。</p>
<p>接下来一行输入 n 个空格隔开的整数，表示输入的数列 a，保证是升序排列，并且 −10<sup>9≤ai≤10</sup>9。</p>
<p>接下来一行输入两个整数 k,s(−10<sup>9≤k,s≤10</sup>9)。</p>
<p>Output</p>
<p>如果能找到满足条件的数，输出&quot;Yes&quot;，否者输出&quot;No&quot;。</p>
<p>Sample Input 1</p>
<p>5<br>
1 2 3 4 5<br>
-1 4<br>
Sample Output 1</p>
<p>Yes<br>
——摘自YCOJ<br>
题目中给出了，一个重要词——升序排列，所以我们可以看出，这道题应该用二分查找法。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main () {
  int n;
  cin &gt;&gt; n;
  int a[n];
  for(int i = 0; i &lt; n; i++){
  	cin &gt;&gt; a [i];
  }
  int k, s;
  cin &gt;&gt; k &gt;&gt; s;
  int l = 0, r = n,x = s-k;
  int mid;
  while(l &lt; r ){
  	int mid=(l+r)/2;
  	if (a[mid]&lt;x){
  	  l = mid + 1;
  }else{
	  r=mid;
	}
  }
  

	if(a[l]==x||a[r]==x) {
		cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
	}
	else {
		cout &lt;&lt; &quot;No&quot; ;
	}
	return 0;
}
</code></pre>
<h4 id="两数之和">两数之和</h4>
<p>Description</p>
<p>给出一个有 n 个元素的数列 a 和一个整数 s，其中数列 a 的元素是按照升序排列的。</p>
<p>请你在数列中找出两个元素 x,y使得的 x+y=s。</p>
<p>Input</p>
<p>输入第一行一个整数 n(1≤n≤10^5)，表示数列中的元素个数。</p>
<p>接下来一个输入 n 个空格隔开的整数，表示输入的数列 a，保证是升序排列，并且 −10<sup>9≤ai≤10</sup>9。</p>
<p>接下来一行输入一个整数 s(−10<sup>9≤x,s≤10</sup>9)。</p>
<p>Output</p>
<p>如果能找到满足条件的两个数，输出&quot;Yes&quot;，否者输出&quot;No&quot;。<br>
——摘自YCOJ<br>
Sample Input 1</p>
<p>5<br>
1 2 3 4 5<br>
4<br>
Sample Output 1</p>
<p>Yes<br>
Sample Input 2</p>
<p>5<br>
1 2 4 4 5<br>
4<br>
Sample Output 2</p>
<p>No<br>
同样的，二分查找。单独用两层for循环枚举是要超时的。<br>
——摘自YCOJ</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[1000010];
int main(){
	 int  n;
	 cin &gt;&gt; n;
	 int ans=0;
	 for(int i=1;i&lt;=n;i++){
	 	cin &gt;&gt; a[i];
	 }
	 int s;
	 cin &gt;&gt; s;
	 for(int i=1;i&lt;=n;i++){
	 		int l =1, r = n, x = s - a [i];
			while(r-l&gt;1){
			int	min=(l+r)/2;
				if(a[min]&lt;x){
					l=min+1;
				}else{
					r=min;
				}
			}
			if(a[l] == x ||a[r]==x){
				ans++;
			}
		}
if (ans&gt;1) {
  cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl;
  }else {
  cout &lt;&lt; &quot;No&quot; &lt;&lt; endl;
}
	return 0;
}
</code></pre>
<h4 id="割绳子">割绳子</h4>
<p>Description</p>
<p>现有 N 条绳子，它们的长度分别为 L1，L2，……，Ln，如果从它们中切割出 K 条长度相同的绳子，这 K 条绳子每条最长能有多长?</p>
<p>Input</p>
<p>输入共有两行，第一行包含两个正整数 N 和 K（1≤N≤1000，1≤K≤1000），用一个空格分隔；第二行包含 N 个数，依次表示 N 条绳子的长度，两数间用一个空格分隔。每条绳子的长度的小数不超过两位（1≤Li≤10000）。</p>
<p>Output</p>
<p>输出仅包含一个数，表示所得 K 条绳子的最大长度。答案四舍五入保留小数点后两位。</p>
<p>Sample Input 1</p>
<p>4 11<br>
8.02 7.43 4.57 5.39<br>
Sample Output 1</p>
<p>2.01<br>
——摘自YCOJ</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
double a[10000001];
int n,k;
int mid(double l){
	int ans=0;
	for(int i=0;i&lt;n;i++){
		ans+=a[i]/l;
	}
	return ans;
}


int main(){
	double mim;
	cin &gt;&gt; n &gt;&gt; k;
	
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
		mim = max(mim,a[i]); 
	}
	
	double l = 0,m;
	double r=mim;
	while (r-l&gt;=1e-9){       
		m=(l+r)/2;
		if(mid(m)&gt;=k){
			l=m;
		}else{
			r=m;
		}
	}
	printf(&quot;%.2lf&quot;,m);
	return 0;
}
</code></pre>
<h4 id="切割钢管">切割钢管</h4>
<p>Description</p>
<p>小白在工地干活。工地现有 nn 根钢管，第 ii 根钢管的长度为 a_ia<br>
i<br>
​	<br>
。</p>
<p>现在小白想用这 nn 根钢管来做一个支撑用的柱子。工人可以切割这些钢管成为更短的钢管，但是不能缝合两根钢管。为了安全起见，柱子必须用 至少 kk 根长度相同的钢管加上混凝土制成，并且要求钢管长度必须为 整数。</p>
<p>小白想知道，这个柱子最高能建成多高。</p>
<p>Input</p>
<p>输入第一行一个整数 n, k (1 \le n, k \le 10000)n,k(1≤n,k≤10000)。</p>
<p>接下来一行输入 nn 个空格隔开的整数 a_i(1 \le l_i \le 10^8)a<br>
i<br>
​	<br>
(1≤l<br>
i<br>
​	<br>
≤10<br>
8<br>
)，表示每根钢管的长度。</p>
<p>Output</p>
<p>输出能够得到的柱子最大高度。</p>
<p>Sample Input 1</p>
<p>2 4<br>
8 4<br>
Sample Output 1</p>
<p>2<br>
Sample Input 2</p>
<p>8 8<br>
12 3 14 12 14 20 4 8<br>
Sample Output 2</p>
<p>7</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
int a[1000010];
int n,k;
int cnt(int len){
	int ans=0;
	for (int i=0;i&lt;n;i++){ 
		ans +=a[i]/len;
	}
	return ans;
}
int main(){
	cin &gt;&gt; n &gt;&gt; k;
 int mx=0;
	for (int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
      mx=max(mx,a[i]);
	}
	int l=0,r=mx,x;
	while (r-l &gt; 1){
		x=(l+r)/2;
		if (cnt(x)&gt;=k){
			l = x;
		}
		else {
			r = x - 1;
		}
	}
	
    if(cnt(r) &lt; k){
    	r=l;
	}
	cout &lt;&lt; r;
	return 0;
}
</code></pre>
<h4 id="火车站台连锁店">火车站台连锁店</h4>
<p>Description</p>
<p>蒜头君建立了一家火车站台连锁店，要在一条铁路线的所有车站里，选择一部分车站开办连锁店，销售各种口味的大蒜。</p>
<p>铁路线上有 nn 个车站，假设这条铁路线是一条直线，其中每个站点的坐标为 x_1,x_2,\ldots,x_nx<br>
1<br>
​	<br>
,x<br>
2<br>
​	<br>
,…,x<br>
n<br>
​	<br>
。</p>
<p>蒜头君一共要开办 mm 个连锁店，并且不希望连锁店离得太近，以使得整体的收益最大化。他希望他的连锁店之间的最近距离尽可能大，你能帮他算出这个最大的最近距离吗？</p>
<p>Input</p>
<p>第一行输入用空格分隔的两个整数 n,m(2 \10^5, 2 \ m  n)n,m(2≤n≤10<br>
5<br>
,2≤m≤n)，分别表示车站数量和连锁店数量。</p>
<p>接下来一共 nn 行，每行一个整数 x_i{0 \leq x_i \leq 10^9}x<br>
i<br>
​	<br>
0≤x<br>
i<br>
​	<br>
≤10<br>
9<br>
，表示车站的坐标。</p>
<p>Output</p>
<p>输出一行整数，表示最大的最近距离。</p>
<p>Sample Input 1</p>
<p>6 3<br>
1<br>
3<br>
5<br>
2<br>
7<br>
9<br>
Sample Output 1</p>
<p>4<br>
Sample Input 2</p>
<p>5 4<br>
5<br>
7<br>
10<br>
28<br>
9<br>
Sample Output 2</p>
<p>2</p>
<pre><code>#include&lt;bits/stdc++.h&gt; 
using namespace std;
int a[1000010];
int n,m;
int cnt(int len){
	int tot=1;
	int last = 0;
	for(int i = 1;i&lt;n;i++){
		if(a[i] - a[last] &gt;= len){
		   	tot++;
			last = i;
        }
    }
	return tot;
}
int main (){ 
	cin &gt;&gt; n &gt;&gt; m;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; a[i];
	}
	sort(a,a+n);
	int l=0,r=a[n - 1],ans;
	while (r - l &gt; 1){
	    ans=(l+r)/2;
		if (cnt(ans) &gt;= m){
			l = ans;
	    }
		else{
			r = ans;
		}
	}
	if(cnt(r)&lt;m){
		r = l;
	}
	cout &lt;&lt; r;
	return 0; 
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[最短路算法]]></title>
        <id>https://ACLYH.github.io/post/zui-duan-lu-suan-fa/</id>
        <link href="https://ACLYH.github.io/post/zui-duan-lu-suan-fa/">
        </link>
        <updated>2020-10-28T13:21:37.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1dijkstra">1.Dijkstra</h4>
<p>Dijkstra用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算<br>
法的主要特点是以起点为中心，逐层向外扩展一个点，每次都会取一个最近点继续扩展，直到取完所有点为止。但Dijkstra 算法要求图中不能出现负权边。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1dijkstra">1.Dijkstra</h4>
<p>Dijkstra用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算<br>
法的主要特点是以起点为中心，逐层向外扩展一个点，每次都会取一个最近点继续扩展，直到取完所有点为止。但Dijkstra 算法要求图中不能出现负权边。</p>
<!-- more -->
<pre><code>//模板
#include&lt;bits/stdc++.h&gt;
using namespace std;


int n,m;

struct node{
	int v,w;
	node(){ };
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
int dst[10100];

void add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){
	memset(dst,0x3f,sizeof dst);
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			int w = g[u][j].w;
			dst[v] = min(dst[v],dst[u]+w);
			
		}
		
		int mi=0x3f3f3f3f;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v,w;
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	
	dij(1);
	cout &lt;&lt; dst[n];
	
	return 0;
}
</code></pre>
<h4 id="2spfa">2.SPFA</h4>
<p>SPFA算法是单源最短路径的一种算法，通常被认为是 Bellmanford算法的队列优化，在代码形式上接近宽度优先搜索 BFS，是一个在实践中非常高效的单源最短路算法。它会在每次更新了最短路以后又重新入队从而去更新后续结点的最短路。同时有些题有卡SPFA的数据，所以也可以换成Dijkstra。但Dijkstra 不能处理有负权的图，而 SPFA 可以处理不含负环的图的最短路，并能 判断是否存在负环。</p>
<pre><code>//模板
#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=1010;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
int inq[maxn];

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}

void spfa(int s){
	memset(dst,inf,sizeof dst);
	int u=s;
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	int u , v , w; 
	while (m--){
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		add(u,v,w);
	}
	spfa(1);
	cout &lt;&lt; dst[n]&lt;&lt;endl;
	return 0;
}
</code></pre>
<h4 id="floyd">Floyd</h4>
<p>基于动态规划思想，个人认为Floyd较Dijkstra和SPFA更难理解，所以就不写太多，但代码很短。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N = 1e2 + 9;
const int inf = 0x3f3f3f3f;
int mp[N][N];
void floyd(int n) {
	for (int k = 1; k &lt;= n; ++k) {
		for (int i = 1; i &lt;= n; ++i) {
			for (int j = 1; j &lt;= n; ++j) {
				mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
			}
		}
	}
}
int main() {
	memset(mp, inf, sizeof mp);
	for (int i = 0; i &lt; N; ++i) {
		mp[i][i] = 0;
	}
int n, m;
int u, v, w;
cin &gt;&gt; n &gt;&gt; m;
	while (m--) {
		cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;
		mp[u][v] = mp[v][u] = w;
	}
	floyd(n);
	for (int i = 1; i &lt;= n; ++i) {
		for (int j = 1; j &lt;= n; ++j) {
			cout &lt;&lt; mp[i][j] &lt;&lt; &quot; &quot;;
		}
		cout &lt;&lt; endl;
	}
return 0;
}
</code></pre>
<h4 id="一些最短路的题目">一些最短路的题目</h4>
<h5 id="1迷阵突围">1.迷阵突围</h5>
<pre><code>

Description

小信陷入了坐标系上的一个迷阵，迷阵上有 n个点，编号从 1 到 n。小信在编号为 1 的位置，他想到编号为 n 的位置上。小信当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在小信知道了 n 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

注意，每条路径上不能重复经过同一个点。

Input

第一行输入两个整数 n (1≤n≤200) 和 m，表示一共有 n 个点和 m 条边。

接下来输入 n 行，每行输入两个整数 xi,yi (−500≤xi,yi≤500)，代表第 i 个点的坐标。

接下来输入 m 行，每行输入两个整数 pj,qj (1≤pj,qj≤n)，表示点 pj 和点 qj 之间相连。

Output

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 -1。

Sample Input 1

3 3
1 1
2 2
3 2
1 2
2 3
1 3

Sample Output 1

2.41


</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,m;

struct node{
	int v;
	double w;
	node(){ };
	node(int _v,double _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[10100];

bool vis[10100];
double dst[10100];

int x[10100],y[10100];
int pre[10100];
void add(int u,int v,double w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){

	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				pre[v]=u;
			}
		}
		
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}

}


void dij2(int s,int uu,int vv){
	
	memset(vis,0,sizeof vis);
	for(int i=1;i&lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&lt;g[u].size();j++){
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(uu ==u &amp;&amp; vv==v || uu==v &amp;&amp; vv == u){
				continue;
			}
	
			dst[v] = min(dst[v],dst[u]+w);

	}
		double mi=1e20;
		for(int j=1;j&lt;=n;j++){
			if(!vis[j]&amp;&amp;mi&gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	 
	}

}


int main(){
	cin &gt;&gt; n &gt;&gt;m;
	int u,v;
	double w;
	
	for(int i=1;i&lt;=n;i++){
		cin &gt;&gt; x[i] &gt;&gt;y[i];
	}
	
	while (m--){
		cin &gt;&gt; u &gt;&gt; v;
		w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
		add(u,v,w);
	}
	
	dij(1);

	
	double mi=1e20;
	for(int i=n;pre[i]!=0;i=pre[i]){
		dij2(1,i,pre[i]);
		mi=min(mi,dst[n]);
	}
	     if(mi == 1e20){
	      cout &lt;&lt; &quot;-1&quot;&lt;&lt;endl;
		 }else{
			 cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;mi&lt;&lt;endl;
		}
	
	return 0;
}
</code></pre>
<h5 id="2p1359-租用游艇">2.P1359 租用游艇</h5>
<pre><code>
题目描述

长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt;=i&lt;=j&lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。

对于给定的游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt;=i&lt;j&lt;=n，编程计算从游艇出租站1 到游艇出租站n所需的最少租金。

保证计算过程中任何时刻数值都不超过10^6
输入输出格式
输入格式：

由文件提供输入数据。文件的第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是一个半矩阵r(i,j),1&lt;=i&lt;j&lt;=n。

输出格式：

程序运行结束时，将计算出的从游艇出租站1 到游艇出租站n所需的最少租金输出到文件中。

输入输出样例
输入样例#1： 

3
5 15
7

输出样例#1： 

12


</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;
int maxn=0x3f3f3f3f; 
int vis[100001];
int dist[10001];
int a[1001][1001];
int main(){
   int n,j,k,l,i;
     cin&gt;&gt;n;
   for(j=0;j&lt;=n;j++){
     for(k=0;k&lt;=n;k++){
        a[j][k]=maxn;
        if(j==k)
            a[j][k]=0;
     }
     dist[j]=maxn;
   }
 
   for(j=1;j&lt;=n;j++){
      for(k=j+1;k&lt;=n;k++){
         cin&gt;&gt;a[j][k];
      }
   }
 
   for(j=1;j&lt;=n;j++){
      dist[j]=a[1][j];
   }
   memset(vis,0,sizeof vis);
   vis[1]=1;
   for(j=1;j&lt;=n;j++){
      int mi=maxn;
      for(i=1;i&lt;=n;i++){
          if(!vis[i]&amp;&amp;dist[i]&lt;mi){
              mi=dist[i];
              k=i;
          }
      }
      vis[k]=1;
 
      for(i=1;i&lt;=n;i++){
          if(!vis[i]&amp;&amp;a[k][i]+dist[k]&lt;dist[i]){
              dist[i]=dist[k]+a[k][i];
          }
      }
  
   }
   cout&lt;&lt;dist[n]&lt;&lt;endl;
 
   return 0;
}
</code></pre>
<h5 id="3p3371-模板单源最短路径弱化版">3.P3371 【模板】单源最短路径（弱化版）</h5>
<p><a href="https://blog.csdn.net/weixin_43913349/article/details/89278981">传送门</a></p>
<h5 id="4p1339-usaco09oct热浪heat-wave">4.P1339 [USACO09OCT]热浪Heat Wave</h5>
<pre><code>
题目描述

The good folks in Texas are having a heatwave this summer. Their Texas Longhorn cows make for good eating but are not so adept at creating creamy delicious dairy products. Farmer John is leading the charge to deliver plenty of ice cold nutritious milk to Texas so the Texans will not suffer the heat too much.

FJ has studied the routes that can be used to move milk from Wisconsin to Texas. These routes have a total of T (1 &lt;= T &lt;= 2,500) towns conveniently numbered 1..T along the way (including the starting and ending towns). Each town (except the source and destination towns) is connected to at least two other towns by bidirectional roads that have some cost of traversal (owing to gasoline consumption, tolls, etc.). Consider this map of seven towns; town 5 is the

source of the milk and town 4 is its destination (bracketed integers represent costs to traverse the route):


                              [1]----1---[3]-
                             /               \
                      [3]---6---[4]---3--[3]--4
                     /               /       /|
                    5         --[3]--  --[2]- |
                     \       /        /       |
                      [5]---7---[2]--2---[3]---
                            |       /
                           [1]------

Traversing 5-6-3-4 requires spending 3 (5-&gt;6) + 4 (6-&gt;3) + 3 (3-&gt;4) = 10 total expenses.

Given a map of all the C (1 &lt;= C &lt;= 6,200) connections (described as two endpoints R1i and R2i (1 &lt;= R1i &lt;= T; 1 &lt;= R2i &lt;= T) and costs (1 &lt;= Ci &lt;= 1,000), find the smallest total expense to traverse from the starting town Ts (1 &lt;= Ts &lt;= T) to the destination town Te (1 &lt;= Te &lt;= T).

德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。

FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T (1 &lt;= T &lt;= 2,500)个城镇，方便地标号為1到T。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。

给定一个地图，包含C (1 &lt;= C &lt;= 6,200)条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re (1 &lt;= Rs &lt;= T; 1 &lt;= Re &lt;= T)，和花费(1 &lt;= Ci &lt;= 1,000)组成。求从起始的城镇Ts (1 &lt;= Ts &lt;= T)到终点的城镇Te(1 &lt;= Te &lt;= T)最小的总费用。
输入输出格式
输入格式：

第一行: 4个由空格隔开的整数: T, C, Ts, Te

第2到第C+1行: 第i+1行描述第i条道路。有3个由空格隔开的整数: Rs, Re和Ci

输出格式：

一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。

输入输出样例
输入样例#1： 复制

7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1

输出样例#1： 复制

7

说明

【样例说明】

5-&gt;6-&gt;1-&gt;4 (3 + 1 + 3)

</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int inf=10100;
queue&lt;int&gt; qu;
int dst[inf];
bool inq[inf];
struct node{
    int t,dist;
};
vector&lt;node&gt; g[inf];
bool spfa(int s){
    memset(dst,0x7f,sizeof(dst));
    memset(inq,0,sizeof(inq));
    dst[s]=0;
    qu.push(s);
    inq[s]=true;
    while(!qu.empty()){
        int u=qu.front();
        qu.pop();
        inq[u]=0;
        for(int i=0;i&lt;g[u].size();i++){
            int v=g[u][i].t;
            int w=g[u][i].dist;
            if(dst[u]+w&lt;dst[v]){
                dst[v]=dst[u]+w;
                if(!inq[v])
                {
                    qu.push(v);
                    inq[v]=1;
                }
            }
        }
    }
}
int main()
{
    int n,m,st,en;
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;st&gt;&gt;en;
    for(int i=0;i&lt;m;i++){
        int x,y,v;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;v;
        g[x].push_back((node){y,v});
        g[y].push_back((node){x,v});
    }
    spfa(st);
    cout&lt;&lt;dst[en];
    return 0;
}
</code></pre>
<p><s>可能你已经发现没有一个用的Floyd，只是因为太蒟了。</s></p>
<h2 id="欧拉回路">欧拉回路</h2>
<p>若图中存在这样一条路径，使得它恰好通过图中每条边一次，则称该路径为 欧拉路径。若该路径<br>
是一个环路，则称为 欧拉（Euler）回路。</p>
<p>1.无向图有欧拉回路的条件<br>
一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数,且该图是连通图。<br>
2.有向图有欧拉回路的条件<br>
一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。</p>
<p>然后，其实也挺简单的。</p>
<p>一道模板题：</p>
<pre><code>题目背景

Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。
题目描述

John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。

每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。

你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。

输入数据保证至少有一个解。
输入输出格式
输入格式：

第1行: 一个整数F(1 &lt;= F &lt;= 1024)，表示栅栏的数目

第2到F+1行: 每行两个整数i, j(1 &lt;= i,j &lt;= 500)表示这条栅栏连接i与j号顶点。

输出格式：

输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。

输入输出样例
输入样例#1： 复制

9
1 2
2 3
3 4
4 2
4 5
2 5
5 6
5 7
4 6

输出样例#1： 复制

1
2
3
4
2
5
4
6
5
7


</code></pre>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1010;
int n;
int eul[maxn][maxn],lu[maxn];
int sum=0;

stack&lt;int&gt; sta;


void dfs(int s){
    for(int i=1;i&lt;=500;i++){
        if(eul[s][i]){
        eul[i][s]--;
        eul[s][i]--;
        
        dfs(i);	
        }
    }
    sta.push(s);
}


int main(){
    
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
    	int x;
    	int y;
    	cin&gt;&gt; x &gt;&gt; y;
    	eul[x][y]++;
    	eul[y][x]++;
    	lu[x]++;
    	lu[y]++;
    }
    int num=1;
    for(int i=1;i&lt;=500;i++){
        if(lu[i]%2){
            num=i;
            break;
        }
    }
    dfs(num);
    while(!sta.empty()){
    	cout &lt;&lt; sta.top()&lt;&lt;endl;
    	sta.pop();
    }
    	
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[DFS]排队（间隔排列）]]></title>
        <id>https://ACLYH.github.io/post/dfspai-dui-jian-ge-pai-lie/</id>
        <link href="https://ACLYH.github.io/post/dfspai-dui-jian-ge-pai-lie/">
        </link>
        <updated>2020-10-28T13:20:00.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="description">Description</h2>
<p>小Q是班长。在校运动会上，小Q班要进行队列表演。小Q要选出2*N名同学编队，每人都被编上一个号，每一个从1到N的自然数都被某2名同学佩戴，现在要求将他们排成一列，使两个编号为1的同学中间恰好夹1名同学，两个编号为2的同学中间恰好夹2名同学，……，两个编号为N的同学中间恰好夹N名同学，小Q希望知道这样的排法能否实现。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>小Q是班长。在校运动会上，小Q班要进行队列表演。小Q要选出2*N名同学编队，每人都被编上一个号，每一个从1到N的自然数都被某2名同学佩戴，现在要求将他们排成一列，使两个编号为1的同学中间恰好夹1名同学，两个编号为2的同学中间恰好夹2名同学，……，两个编号为N的同学中间恰好夹N名同学，小Q希望知道这样的排法能否实现。</p>
<!-- more -->
<h2 id="input">Input</h2>
<p>输入文件仅包括一行，即要处理的N。N&lt;=13</p>
<h2 id="output">Output</h2>
<p>输出有多少种排列顺序.</p>
<h2 id="sample-input">Sample Input</h2>
<p>3</p>
<h2 id="sample-output">Sample Output</h2>
<p>2</p>
<p>先理解一下题目，题目中所述，每一个从1到N的自然数都被某2名同学佩戴，说明共有2N名同学，两个编号为N的同学中间恰好夹N名同学，就可以得到一个排列（以n==3为例）：</p>
<p><img src="https://img-blog.csdnimg.cn/20190714092334172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
然后，就可以用DFS搜索了。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,ans=0;
int flag[100]={0};

void dfs(int dep){
	
	if(dep&gt;n){
		ans++;
		return ;
	}
	for(int i=1;i&lt;=2*n-dep-1;i++){
		if(!flag[i]&amp;&amp;!flag[i+dep+1]){//考虑当前位置有无其他数，和它的间隔有没有其他数
			flag[i]=flag[i+dep+1]=1;
			dfs(dep+1);
			flag[i]=flag[i+dep+1]=0;
		}
	}
}
int main(){
	cin &gt;&gt; n;
	dfs(1);
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
<p>但是，可以发现，当程序运行12或13时，耗时很长，那么就可以想到剪枝优化。</p>
<pre><code>	if(n%4==1||n%4==2){
		return ; 
	}
</code></pre>
<p>现在，就可以证明一下这个剪枝的得到。<br>
设问题的一个解为a1+a2···+an,a1表示1。<br>
那么可以得到  a1+a2+…+an+(a1+1+1)+(a2+2+1)+…+(an+n+1) ，最后解得 4(a1+a2+…+an)=n(3n-1) ，所以n%4<mark>1或n%4</mark>2无解。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n,ans=0;
int flag[100]={0};

void dfs(int dep){
	
	if(n%4==1||n%4==2){
		return ; 
	}
	if(dep&gt;n){
		ans++;
		return ;
	}
	for(int i=1;i&lt;=2*n-dep-1;i++){
		if(!flag[i]&amp;&amp;!flag[i+dep+1]){
			flag[i]=flag[i+dep+1]=1;
			dfs(dep+1);
			flag[i]=flag[i+dep+1]=0;
		}
	}
}
int main(){
	cin &gt;&gt; n;
	dfs(1);
	cout &lt;&lt; ans;
	
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[2020-10-27 模拟考]]></title>
        <id>https://ACLYH.github.io/post/2020-10-27-mo-ni-kao/</id>
        <link href="https://ACLYH.github.io/post/2020-10-27-mo-ni-kao/">
        </link>
        <updated>2020-10-28T11:06:16.000Z</updated>
        <summary type="html"><![CDATA[<p>三道题目，有两道还是普及组T3和T4原题。。。<br>
<s>然鹅我似乎还是炸了呢</s></p>
]]></summary>
        <content type="html"><![CDATA[<p>三道题目，有两道还是普及组T3和T4原题。。。<br>
<s>然鹅我似乎还是炸了呢</s></p>
<!-- more -->
<p>T1<br>
<a href="https://www.luogu.com.cn/problem/P5661">公交换乘</a><br>
著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：</p>
<p>在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：tbus−tsubway≤45<br>
搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。<br>
搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。<br>
现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?</p>
<p>输入格式<br>
输入文件的第一行包含一个正整数 n，代表乘车记录的数量。</p>
<p>接下来的 n 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。第 i 行的第 1 个整数代表第 i条记录乘坐的交通工具，0 代表地铁，1 代表公交车；第 2 个整数代表第 i 条记录乘车的票价 price<br>
i<br>
​	<br>
；第三个整数代表第 i 条记录开始乘车的时间 t<br>
i<br>
​	<br>
（距 0 时刻的分钟数）。</p>
<p>我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。</p>
<p>输出格式<br>
输出文件有一行，包含一个正整数，代表小轩出行的总花费。</p>
<p>输入输出样例<br>
输入 #1</p>
<pre><code>6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135
输出 #1
36
输入 #2
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 
输出 #2
32
</code></pre>
<p>乘坐地铁的价格可以直接加入ans，主要处理在公交车是否免费的判断上。<br>
因为队列的性质是先进先出，而题目恰好要求如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。所以可以模拟队列，其中用一个结构体来表示优惠票的改变。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
struct node{
	int pr,time,use;
}q[110001];//免费票的价格上限，能用的时间，是否可用；
int n;
int op,pri,ti,ans;
int tail,head;//模拟队列
int main(){
	cin &gt;&gt; n;
	for(int i=0;i&lt;n;i++){
		cin &gt;&gt; op &gt;&gt; pri &gt;&gt; ti;
		if(op==0){//如果是地铁的情况
			ans+=pri;//直接将价格加入ans
			q[tail].time = ti + 45;//时间范围
			q[tail++].pr = pri; //存入票价
		}else if(op == 1){//公交车
			while (head &lt; tail &amp;&amp; q[head].time &lt; ti) {
                head++;
            }//放弃超过时间限制的票
            bool flag = 0;//标记
            for(int j=head;j&lt;tail;j++){
            	if(q[j].pr &gt;= pri &amp;&amp; q[j].use == 0){//如果存在免费票大于公交车价格的票，且没有没用过
            		flag = 1;
            		q[j].use = 1;//标记为用过
            		break;
				}
			}	
		if(!flag){
			ans+=pri;//如果不行，就将价格直接加入ans
		}
		}
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<p>T2<br>
<a href="https://www.luogu.com.cn/problem/P5018">对称二叉树</a><br>
<s>有一道做过好几遍的题</s><br>
当时在NOI考场上我一脸懵逼，现在想来······</p>
<p>一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：<br>
二叉树；<br>
将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。<br>
下图中节点内的数字为权值，节点外的 id 表示节点编号。</p>
<p>现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。</p>
<p>注意：只有树根的树也是对称二叉树。本题中约定，以节点 TT 为子树根的一棵“子 树”指的是：节点TT 和它的全部后代节点构成的二叉树。</p>
<p>输入格式<br>
第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>∼</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1∼n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∼</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>，其中节点 11 是树根。</p>
<p>第二行 n 个正整数，用一个空格分隔，第 i 个正整数 v_i 代表节点 i 的权值。</p>
<p>接下来 n 行，每行两个正整数 l_i, r_i ，分别表示节点 ii 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1−1 表示。两个数之间用一个空格隔开。<br>
输出格式<br>
输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。<br>
输入输出样例</p>
<pre><code>输入 #1
2 
1 3 
2 -1 
-1 -1 
输出 #1
1
输入 #2
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8
输出 #2
3
</code></pre>
<p>DFS可以水过去。<br>
搜索思路比较好想，以每个节点为根节点，判断左子树的值是否等于右子树值，就能找到它们是否是对称二叉树。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

int n;
int l[1010000],r[1010010];//左子树，右子树
bool vis;int a[10100100];
int ans=1 ;
int dfs(int x,int y,int s)//正在访问的节点，s为当前节点。
{
	if(x==-1&amp;&amp;y==-1)return 0;//返回条件
	if(x==-1||y==-1&amp;&amp;x!=y){
		vis=1;
		return 0;	
	}//对称二叉树
	if(a[x]!=a[y]){
		vis=1;
		return 0;
	}//对称
	return  dfs(l[x],r[y],2) + dfs(r[x],l[y],2) + s;
}

int main(){
	scanf(&quot;%d&quot;,&amp;n);
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d&quot;,&amp;a[i]);
	}
	for(int i=1;i&lt;=n;i++){
		scanf(&quot;%d%d&quot;,&amp;l[i],&amp;r[i]);
	}
	for(int i=1;i&lt;=n;i++){
		if(dfs(l[i],r[i],3)&gt;ans&amp;&amp;vis==0){
			ans = dfs(l[i],r[i],3);
		}
		vis = 0;
	}
	cout &lt;&lt; ans;
	return 0;
}
</code></pre>
<p>T3<br>
<a href="http://forioi.com/p/6217">photo</a></p>
<p>啊这。。状压DP？<s>（然鹅考场上并不会）</s></p>
<p>有N个人，来自K个家族.他们排成一行准备照相，但是由于天生的排外性，每个人都希望和本家族的人站在一起,中间不要加入别的家族的人.问最少从队列中去掉多少个就可以达到这个目的.<br>
输入<br>
第一行给出N,K。N在[1,100]，K在[1,5] 第二行给出N个数，每个数为1到K中的某个数。<br>
输出<br>
最少从队列中去掉多少个就可以达到这个目的</p>
<p>样例<br>
输入<br>
10 3<br>
2 1 2 2 1 1 3 1 3 3</p>
<p>输出<br>
2</p>
<p>DP求解可以保留最多的人数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>−</mo><mi>a</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">n-ans</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>即为所求。<br>
所以就看那种方法最优，要么当前状态是一个新的家族，要么保持连通，当前这个人与上一个同属于一个家族。</p>
<p>用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>k</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i][j][k]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">]</span></span></span></span>三个量来表示第i个人，第j状态，前一个人是第K家族的保留人数。</p>
<p>一为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><msup><mi>j</mi><mo>(</mo></msup><mn>1</mn><mo>&lt;</mo><mo>&lt;</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>−</mo><mn>1</mn><mo>)</mo><mo>]</mo><mo>[</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j ^ (1 &lt;&lt; a[i] - 1)][+ 1);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.138em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mopen mtight">(</span></span></span></span></span></span></span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">+</span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span> 当前出现的家族。<br>
二为与上一个家族的人相同，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>[</mo><mi>a</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo><mo>+</mo><mn>1</mn><mo>)</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j][a[i]] + 1);</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">;</span></span></span></span></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
 int ans = 0;
int n, k, a[101001];
int dp[200][1000][10];
int main() {
    cin &gt;&gt; n &gt;&gt;k;
    for(int i = 1; i &lt;= n; i++){
    cin &gt;&gt; a[i];	
    }
     
    for(int i = 1; i &lt;= n; i++) {
        memcpy(dp[i], dp[i - 1], sizeof dp[i - 1]);
                 
        for(int j = 0; j &lt; (1 &lt;&lt; k); j++) {
            if(j &amp; (1 &lt;&lt; a[i] - 1)) {
                dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j][a[i]] + 1);
                for(int l = 0; l &lt;= k; l++){
                	dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j ^ (1 &lt;&lt; a[i] - 1)][l] + 1);
            		}
				}     
        }
    }
    for(int j = 0; j &lt; (1 &lt;&lt; k); j++)
        for(int l = 0; l &lt;= k; l++) 
            ans = max(ans, dp[n][j][l]);
             
    cout &lt;&lt;  n - ans;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[差分约束]]></title>
        <id>https://ACLYH.github.io/post/chai-fen-yue-shu/</id>
        <link href="https://ACLYH.github.io/post/chai-fen-yue-shu/">
        </link>
        <updated>2020-10-28T10:57:40.000Z</updated>
        <summary type="html"><![CDATA[<h4 id="1差分约束系统system-of-difference-constraints">1.差分约束系统（system of difference constraints）</h4>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。</p>
]]></summary>
        <content type="html"><![CDATA[<h4 id="1差分约束系统system-of-difference-constraints">1.差分约束系统（system of difference constraints）</h4>
<p>如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。</p>
<!-- more -->
<p>求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。<br>
——百度百科<br>
如下列的不等式组</p>
<pre><code>x1-x5≤-1
x2-x5≤1
x3-x1≤5
x4-x1≤4
x4-x3≤-1
x5-x3≤-3
x5-x4≤-3
</code></pre>
<p>比如1式 x1-x5≤-1，其中一个未知数x1与x5的差小于等于-1，就相当于设两个未知数x，y差为某一常数，由这些不等式构成的不等式方程组为差分约束系统。</p>
<h4 id="2例题">2.例题</h4>
<h6 id="小k的农场">小K的农场</h6>
<p>关于洛谷一道蓝题。<br>
<a href="https://www.luogu.org/problemnew/show/P1993">P1993 小K的农场</a><br>
但因为在另一篇题解中写过了，所以不多做阐述，解题看好差分约束条件就行了。<br>
<a href="https://blog.csdn.net/weixin_43913349/article/details/89280139">小K的农场（差分约束）题解</a></p>
<p>然后是另外两道题</p>
<h6 id="蒜头君的银行卡">蒜头君的银行卡</h6>
<p>Description</p>
<p>虽然蒜头君并没有多少钱，但是蒜头君办了很多张银行卡，共有 n 张，以至于他自己都忘记了每张银行卡里有多少钱了。他只记得一些含糊的信息，这些信息主要以下列三种形式描述：</p>
<p>银行卡 a 比银行卡 b 至少多 c 元。<br>
银行卡 a 比银行卡 b 至多多 c 元。<br>
银行卡 a 和银行卡 c 里的存款一样多。<br>
但是由于蒜头君的记忆有些差，他想知道是否存在一种情况，使得银行卡的存款情况和他记忆中的所有信息吻合。</p>
<p>Input<br>
第一行输入两个整数 n 和 m，分别表示银行卡数目和蒜头君记忆中的信息的数目。(1≤n,m≤10000)</p>
<p>接下来 m 行：</p>
<p>如果每行第一个数是 1，接下来有三个整数 a,b,c，表示银行卡 a 比银行卡 b 至少多 c元。</p>
<p>如果每行第一个数是 2，接下来有三个整数 a,b,c，表示银行卡 a 比银行卡 b 至多多 c元。</p>
<p>如果每行第一个数是 3，接下来有两个整数 a,b，表示银行卡 a 和 b 里的存款一样多。(1≤n,m,a,b,c≤10000)</p>
<p>Output<br>
如果存在某种情况与蒜头君的记忆吻合，输出Yes，否则输出No。</p>
<p>Sample Input 1</p>
<p>3 3<br>
3 1 2<br>
1 1 3 1<br>
2 2 3 2<br>
Sample Output 1</p>
<p>Yes</p>
<p>很明显，题目中出现了几个约束条件：<br>
银行卡 a 比银行卡 b 至少多 c 元。<br>
银行卡 a 比银行卡 b 至多多 c 元。<br>
银行卡 a 和银行卡 c 里的存款一样多。</p>
<p>转化为不等式方程组：</p>
<p>a-b&gt;=c<br>
a-b&lt;=c<br>
a=c</p>
<p>找到了解题的关键，然后将差分约束转化为最短路求解 。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10100;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
bool inq[maxn];
int cnt[maxn];


int add(int u,int v,int w){
	g[u].push_back(node(v,w));
//	g[v].push_back(node());
}

int spfa(int u){
	memset(inq,0,sizeof inq);
	memset(dst,inf,sizeof dst);
	memset(cnt,0,sizeof cnt);
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	cnt[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
					cnt[v]++;
					if(cnt[v]&gt;n+1){
					return 0;	
					}
				}
			}
		}
	}
	return 1;
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	
	for(int i=0;i&lt;m;i++){
		int d,a,b,c;
		cin &gt;&gt; d;
		if(d==1){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a].push_back(node(b,-c));
		}else if(d==2){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[b].push_back(node(a,-c));
		}else{
			cin &gt;&gt;a&gt;&gt;b;
			g[a].push_back(node(b,0));
			g[b].push_back(node(a,0));
		}
	}
	
	for(int i=1;i&lt;=n;i++){
		add(0,i,0);
	}
	if(spfa(0)){
	cout &lt;&lt; &quot;Yes&quot;&lt;&lt;endl;
}else{
	cout &lt;&lt; &quot;No&quot;;
}
	return 0;
}
</code></pre>
<h6 id="蒜头君当大厨">蒜头君当大厨</h6>
<pre><code>Description

蒜头君苦练厨艺，终于成为了某高档酒店的大厨。

每天上班，蒜头君会被要求做 n 份菜。既然是高档酒店，那么客人们当然是很讲究的，尤其对于上菜的时间有很多要求。客人们的要求被分成下列四种：

菜品 a 的上菜时间必须比菜品 b 的上菜时间早 d 分钟或者更早。

菜品 a 的上菜时间必须比菜品 b 的上菜时间迟 d 分钟或者更迟。

菜品 a 的上菜时间在 d 分钟以后(包含 d 分钟)。

菜品 a 的上菜时间在 d 分钟之前(包含 d 分钟)。

蒜头君的上班时间记为 0 分钟。为了节约时间，在满足客人们要求的情况下，蒜头君希望最后上的一道菜的时间尽可能的早。（每道菜的上菜时间必须不早于蒜头君的上班时间）


Input
第一行输入一个整数 n，表示一共需要上 n 道菜。

第二行输入一个整数 m，表示客人们的要求数量。

接下里 m 行，每行先输入一个整数 op。

如果 op=1，表示描述里的第 1 种要求，后面跟着三个整数 a,b,d。
如果 op=2，表示描述里的第 2 种要求，后面跟着三个整数 a,b,d。
如果 op=3，表示描述里的第 3 种要求，后面跟着两个整数 a,d。
如果 op=4，表示描述里的第 4 种要求，后面跟着两个整数 a,d。

Output
如果蒜头君能满足客人们的要求，输出最后一道菜的上菜时间；否则输出一行 'I can't'。

数据范围和约定

对于所有的数据：1≤n,m≤20000，1≤∣d∣≤10000 ,1≤a,b≤n，a≠b。

样例解释 1

1,2,3 的上菜时间分别为 0,2,12，这样能满足输入客人们的所有要求，并且时间最短。



Sample Input 1 

3
5
2 3 2 10
2 2 1 2
2 3 2 5
1 2 3 7
3 3 9
Sample Output 1

12
Sample Input 2 

3
4
3 1 3
2 3 1 9
2 1 3 -1
1 1 2 5
Sample Output 2

I can't
Sample Input 3 

17
20
2 6 3 -21
1 8 2 54
3 7 -95
4 11 44
1 5 15 40
3 9 1
3 3 30
3 8 23
2 9 12 -15
4 13 61
2 3 7 31
1 5 10 -15
2 16 1 43
2 12 3 -79
2 14 16 -51
3 6 48
4 7 0
2 10 11 -59
2 12 17 -29
3 4 10
Sample Output 3

77
</code></pre>
<p>与蒜头君的银行卡差不多，都是找到差分约束条件：<br>
菜品 a 的上菜时间必须比菜品 b 的上菜时间早 d 分钟或者更早。</p>
<p>菜品 a 的上菜时间必须比菜品 b 的上菜时间迟 d 分钟或者更迟。</p>
<p>菜品 a 的上菜时间在 d 分钟以后(包含 d 分钟)。</p>
<p>菜品 a 的上菜时间在 d 分钟之前(包含 d 分钟)。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=20010;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &lt;node&gt; g[maxn];
int dst[maxn];
queue &lt;int&gt; qu;
bool inq[maxn];
int cnt[maxn];
int flag;

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
//	g[v].push_back(node());
}

void spfa(int u){
	memset(inq,0,sizeof inq);
	memset(dst,0x80,sizeof dst);
	memset(cnt,0,sizeof cnt);
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	cnt[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&lt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
					cnt[v]++;
					if(cnt[v]&gt;n+1){
						return;
					}
					if(cnt[v]==n+1){
						flag=1;
					}
				}
			}
		}
	}
	return;
}


int main(){
	cin &gt;&gt; n &gt;&gt; m;
	
	for(int i=0;i&lt;m;i++){
		int d,a,b,c;
		cin &gt;&gt; d;
		if(d==1){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[a].push_back(node(b,c));
		}else if(d==2){
			cin &gt;&gt;a&gt;&gt;b&gt;&gt;c;
			g[b].push_back(node(a,c));
		}else if(d==3){
			cin &gt;&gt;a&gt;&gt;b;
			g[0].push_back(node(a,b));
		}else{
			cin &gt;&gt;a&gt;&gt;b;
			g[0].push_back(node(0,-b));
		}
	}
	
	for(int i=1;i&lt;=n;i++){
		add(0,i,0);
	}
int ans=0;
spfa(0);

if(flag){
	cout&lt;&lt;&quot;I can't&quot;;
	return 0;
}
 
 for(int i=1;i&lt;=n;i++){
 ans=max(ans,dst[i]);
}
cout &lt;&lt; ans;
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[Noip2010]机器翻译-C++]]></title>
        <id>https://ACLYH.github.io/post/noip2010ji-qi-fan-yi-c/</id>
        <link href="https://ACLYH.github.io/post/noip2010ji-qi-fan-yi-c/">
        </link>
        <updated>2020-10-28T10:37:32.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="description">Description</h2>
<p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。这个翻译软件的原理很简单，它只是<br>
从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的<br>
中文含义</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="description">Description</h2>
<p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。这个翻译软件的原理很简单，它只是<br>
从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的<br>
中文含义</p>
<!-- more -->
<p>，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词<br>
的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有 M 个单元，每单元<br>
能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M?1，软件会<br>
将新单词存入一个未使用的内存单元；若内存中已存入 M 个单词，软件会清空最早进入内存的那个单词，腾出单<br>
元来，存放新单词。假设一篇英语文章的长度为 N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词<br>
典？假设在翻译开始前，内存中没有任何单词。</p>
<h2 id="input">Input</h2>
<p>输入文件共 2 行。每行中两个数之间用一个空格隔开。<br>
第一行为两个正整数 M和 N，代表内存容量和文章的长度。<br>
第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文 单词。文章中两个单词是<br>
同一个单词，当且仅当它们对应的非负整数相同。<br>
0&lt;M≤100，0&lt;N≤1000</p>
<h2 id="output">Output</h2>
<p>包含一个整数，为软件需要查词典的次数。</p>
<h2 id="sample-input">Sample Input</h2>
<p>3 7<br>
1 2 1 5 4 4 1</p>
<h2 id="sample-output">Sample Output</h2>
<p>5<br>
//整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：<br>
空：内存初始状态为空。<br>
1． 1：查找单词1 并调入内存。<br>
2． 1 2：查找单词 2 并调入内存。<br>
3． 1 2：在内存中找到单词 1。<br>
4． 1 2 5：查找单词 5 并调入内存。<br>
5． 2 5 4：查找单词 4 并调入内存替代单词 1。<br>
6． 2 5 4：在内存中找到单词 4。<br>
7． 5 4 1：查找单词 1 并调入内存替代单词 2。<br>
共计查了 5次词典。</p>
<p>其实就是队列的操作，找到一个新单词，就将它存入队列不断更新。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
int a[10000];
int main(){
    queue&lt;int&gt; q;
    int m,n,ans=0;
    int b;
    cin  &gt;&gt; m &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
        cin &gt;&gt; b;
        if(!a[b]){
            ans++;
            if(q.size()&lt;m){
                a[b]=1;
                q.push(b);
            }else if(m!=0){
                a[q.front()]=0;
                a[b]=1;
                q.pop();
                q.push(b);
            }
        }
         
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[栈]]></title>
        <id>https://ACLYH.github.io/post/zhan/</id>
        <link href="https://ACLYH.github.io/post/zhan/">
        </link>
        <updated>2020-10-25T08:37:05.000Z</updated>
        <summary type="html"><![CDATA[<hr>
<p>一个，跟队列同样基础的数据结构。。。<br>
栈就是一种有限制的线性表，限制在于它只能先进后出。栈顶的第一个元素是栈顶元素，相反的是栈底。相当于吃薯片时，将薯片装入桶中为进栈，拿出来为出栈。</p>
]]></summary>
        <content type="html"><![CDATA[<hr>
<p>一个，跟队列同样基础的数据结构。。。<br>
栈就是一种有限制的线性表，限制在于它只能先进后出。栈顶的第一个元素是栈顶元素，相反的是栈底。相当于吃薯片时，将薯片装入桶中为进栈，拿出来为出栈。</p>
<!--more-->
<p>###STL库</p>
<pre><code>stack&lt;T&gt;//T为一种变量类型
</code></pre>
<p>###stack操作</p>
<pre><code>push()-入栈
pop()-出栈
clear()-清空栈
top()-取栈顶元素
size()-栈的大小
empty()-清空栈
</code></pre>
<p>图论中的欧拉回路就有一定栈的使用。<br>
<a href="https://www.luogu.org/problem/P2731">P2731 骑马修栅栏 Riding the Fences<br>
</a></p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1010;
int n;
int eul[maxn][maxn],lu[maxn];
int sum=0;

stack&lt;int&gt; sta;//开一个栈

void dfs(int s){
    for(int i=1;i&lt;=500;i++){
        if(eul[s][i]){
        eul[i][s]--;
        eul[s][i]--;
        
        dfs(i);	
        }
    }
    sta.push(s);//将元素s入栈
}


int main(){
    cin &gt;&gt; n;
    for(int i=1;i&lt;=n;i++){
    	int x;
    	int y;
    	cin&gt;&gt; x &gt;&gt; y;
    	eul[x][y]++;
    	eul[y][x]++;
    	lu[x]++;
    	lu[y]++;
    }
    int num=1;
    for(int i=1;i&lt;=500;i++){
        if(lu[i]%2){
            num=i;
            break;
        }
    }
    dfs(num);
    while(!sta.empty()){//栈是否为空
    	cout &lt;&lt; sta.top()&lt;&lt;endl;//输出栈顶元素
    	sta.pop();//出栈
    }
    	
    return 0;
} 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[并查集（Disjoint Set Union）]]></title>
        <id>https://ACLYH.github.io/post/bing-cha-ji-disjoint-set-union/</id>
        <link href="https://ACLYH.github.io/post/bing-cha-ji-disjoint-set-union/">
        </link>
        <updated>2020-10-25T08:31:48.000Z</updated>
        <summary type="html"><![CDATA[<hr>
<h3 id="1并查集">1.并查集</h3>
<p>在一些有N个元素的集合问题中，我们通常是在开始让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。然而可以知道，这样空间时间复杂度极高，无法通过题目的时限，这个时候，就可以用到并查集来解答。</p>
]]></summary>
        <content type="html"><![CDATA[<hr>
<h3 id="1并查集">1.并查集</h3>
<p>在一些有N个元素的集合问题中，我们通常是在开始让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。然而可以知道，这样空间时间复杂度极高，无法通过题目的时限，这个时候，就可以用到并查集来解答。</p>
<!-- more -->
<p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。<br>
<img src="https://img-blog.csdnimg.cn/20190518155257812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="2初始化">2.初始化</h3>
<p>初始化很简单，将每个点所在集合初始化为它自己。如有n个点，就将数组fa[i]=i</p>
<pre><code>void init(){
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
	}
}
</code></pre>
<h3 id="3查找">3.查找</h3>
<p>这一步，我们只需要找到根节点，即元素所在的集合。就是当fa[x]等于x时，就找到了根节点，return x。反之，继续查找。</p>
<pre><code>int get(int x){
	if(fa[x]==x) return x;
	return get(fa[x]);
}
</code></pre>
<h3 id="4合并">4.合并</h3>
<p>将两个不同元素所在的集合合并为一个集合。</p>
<pre><code>void merge(int x,int y){
	fa[get(x)] = get(y);
}
</code></pre>
<p>现在，让我们来看看模板的实现</p>
<h3 id="5思路例题">5.思路&amp;例题</h3>
<h4 id="p1551-亲戚">P1551 亲戚</h4>
<p>题目背景</p>
<p>若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。<br>
题目描述</p>
<p>规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。<br>
输入输出格式<br>
输入格式：</p>
<p>第一行：三个整数n,m,p，（n&lt;=5000,m&lt;=5000,p&lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。</p>
<p>以下m行：每行两个数Mi，Mj，1&lt;=Mi，Mj&lt;=N，表示Mi和Mj具有亲戚关系。</p>
<p>接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。</p>
<p>输出格式：</p>
<p>P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。</p>
<p>输入输出样例<br>
输入样例#1： 复制</p>
<p>6 5 3<br>
1 2<br>
1 5<br>
3 4<br>
5 2<br>
1 3<br>
1 4<br>
2 3<br>
5 6</p>
<p>输出样例#1： 复制</p>
<p>Yes<br>
Yes<br>
No</p>
<p>这道题就可以用并查集来实现。<br>
相当于<br>
<img src="https://img-blog.csdnimg.cn/20190518162322855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
如图，x为y的亲戚，而y又为z的亲戚，所以z为x的亲戚。<br>
然后，就可以搞一波了：</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10010;


int n,m,p;
int fa[maxn];

void init(){
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
	}
}
int get(int x){
	if(fa[x]==x) return x;
	return get(fa[x]);
}

void merge(int x,int y){
	fa[get(x)] = get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt; m&gt;&gt;p;
	init();
	int x,y;
	for(int i=1;i&lt;=m;i++){
		cin &gt;&gt; x &gt;&gt; y;
		merge(x,y);
	}
	for(int i=1;i&lt;=p;i++){
		cin &gt;&gt; x &gt;&gt; y;
	    if(get(x)==get(y))cout &lt;&lt; &quot;Yes&quot;&lt;&lt;endl;
		else cout &lt;&lt; &quot;No&quot; &lt;&lt;endl;
	}

	return 0;
}
</code></pre>
<p>但是，不妨想想，这样做会不会太麻烦？<br>
如果z想要知道自己还有没有亲戚，那他就必须问y，才能找到x，这样，会不会耗时间。<br>
再想想，如果有很多亲戚，找起来会不会太慢？<br>
所以，现在看看另一道题</p>
<h4 id="p3367-模板并查集">P3367 【模板】并查集</h4>
<p>题目描述</p>
<p>如题，现在有一个并查集，你需要完成合并和查询操作。<br>
输入输出格式<br>
输入格式：</p>
<p>第一行包含两个整数N、M，表示共有N个元素和M个操作。</p>
<p>接下来M行，每行包含三个整数Zi、Xi、Yi</p>
<p>当Zi=1时，将Xi与Yi所在的集合合并</p>
<p>当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N</p>
<p>输出格式：</p>
<p>如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N</p>
<p>输入输出样例<br>
输入样例#1：</p>
<p>4 7<br>
2 1 2<br>
1 1 2<br>
2 1 2<br>
1 3 4<br>
2 1 4<br>
1 2 3<br>
2 1 4</p>
<p>输出样例#1：</p>
<p>N<br>
Y<br>
N<br>
Y</p>
<p>说明</p>
<p>时空限制：1000ms,128M</p>
<p>数据规模：</p>
<p>对于30%的数据，N&lt;=10，M&lt;=20；</p>
<p>对于70%的数据，N&lt;=100，M&lt;=1000；</p>
<p>对于100%的数据，N&lt;=10000，M&lt;=200000。</p>
<p>这倒就要用到路径压缩。<br>
如何压缩？<br>
简单来说就是将原本的子孙节点全部直接连到根节点上。<br>
<img src="https://img-blog.csdnimg.cn/20190531200520930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"><br>
让它们直接找到x，就行了。<br>
所以，只需要改一改</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10010;


int n,m;
int fa[maxn];

void init(){
	for(int i=1;i&lt;=n;i++){
		fa[i]=i;
	}
}
int get(int x){
	if(fa[x]==x) return x;
	return fa[x]=get(fa[x]);
}

void merge(int x,int y){
	fa[get(x)] = get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt; m;
	init();
	int x,y,z;
	for(int i=1;i&lt;=m;i++){
		cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;
		if(x==1){
		merge(y,z);
	    }else if(get(y)==get(z))cout &lt;&lt; &quot;Y&quot;&lt;&lt;endl;
		else cout &lt;&lt; &quot;N&quot; &lt;&lt;endl;
	}

	return 0;
}
</code></pre>
<h4 id="各种各样的并查集">各种各样的并查集</h4>
<h5 id="网络交友">网络交友</h5>
<p>Description</p>
<p>在网络社交的过程中，通过朋友，也能认识新的朋友。在某个朋友关系图中，假定 A 和 B 是朋友，B 和 C 是朋友，那么 A 和 C 也会成为朋友。即，我们规定朋友的朋友也是朋友。</p>
<p>现在要求你每当有一对新的朋友认识的时候，你需要计算两人的朋友圈合并以后的大小。</p>
<p>Input</p>
<p>第一行：一个整数 n(n≤5000)n(n\leq 5000)n(n≤5000)，表示有 nnn 对朋友认识。</p>
<p>接下来 nnn 行：每行输入两个名字。表示新认识的两人的名字，用空格隔开。（名字是一个首字母大写后面全是小写字母且长度不超过 20 的串）。</p>
<p>Output</p>
<p>对于每一对新认识的朋友，输出合并以后的朋友圈的大小。</p>
<p>Sample Input 1</p>
<p>3<br>
Fred Barney<br>
Barney Betty<br>
Betty Wilma</p>
<p>Sample Output 1</p>
<p>2<br>
3<br>
4</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=10010;
int n,k;
int sz[maxn],fa[maxn];

map&lt;string, int&gt;mp;

void init(){
	for(int i=1;i&lt;=n+1;i++){
		fa[i]=i;
		sz[i]=1;
	}
}

int get(int x){
	if(fa[x]==x) return x;
	else return fa[x]=get(fa[x]);
}

void merge(int x,int y){
	int tx=get(x);
	int ty=get(y);
	if(tx!=ty){
		fa[tx]=ty;
        sz[ty]+=sz[tx];
	}
}

int main(){
	cin &gt;&gt; n;
	int ans=0;
	init();
	string s1,s2;
	while(n--){
		cin &gt;&gt; s1 &gt;&gt; s2;
		int x,y;
		if((x=mp[s1]) == 0) x = mp[s1] = ++k;
		if((y=mp[s2]) == 0) y = mp[s2] = ++k;
		merge(x,y);
		cout &lt;&lt; sz[get(y)] &lt;&lt; endl;
			}
	
	return 0;
}
</code></pre>
<h5 id="昆虫的生活">昆虫的生活</h5>
<p>Description</p>
<p>一天蒜头君正在研究一种稀有昆虫的行为。他们具有两种不同的性别，他假设他们只与异性昆虫互动。因为他们背上都印有数字，所以他们之间的一起互动，在实验室是很容易识别的。</p>
<p>现在给出一些昆虫之间的互动，看看实验是否支持蒜头君的假设--只有异性互动。</p>
<p>Input</p>
<p>第一行输入两个整数 nnn (1≤n≤2000)(1 \le n \le 2000)(1≤n≤2000) ， mmm (1≤m≤106)(1 \le m \le 10^6)(1≤m≤106)。其中 nnn 表示昆虫的数目，mmm 表示昆虫互动的关系数量。</p>
<p>接下来会有 mmm 行，每行有两个整数 xxx ， yyy (1≤x,y≤n)(1 \le x,y \le n)(1≤x,y≤n)。表示昆虫 xxx 和昆虫 yyy 之间有过互动。</p>
<p>Output</p>
<p>判断蒜头君的假设是否正确，如果正确请输入yes，否则输出no。</p>
<p>Sample Input 1</p>
<p>3 3<br>
1 2<br>
2 3<br>
1 3</p>
<p>Sample Output 1</p>
<p>no</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn=5010;

struct node{
	int x,y;
}g[10000010];

int fa[maxn*2];
int n,m;
int init(){
	for(int i=1;i&lt;=n*2;i++){
		fa[i]=i;
	}
}

int get(int x){
	if(fa[x]==x)return x;
	int r=get(fa[x]);
	fa[x]=r;
	return r;
}

void merge(int x,int y){
	fa[get(x)]=get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt;m;
	init();
	for(int i=1;i&lt;=m;i++){
		cin &gt;&gt; g[i].x  &gt;&gt; g[i].y;
	}
	for(int i=1;i&lt;=m;i++){
		if(get(g[i].x)==get(g[i].y)) {
		cout &lt;&lt;&quot;no&quot;&lt;&lt;endl;
		return 0;
	}
		merge(g[i].x,g[i].y+n);
		merge(g[i].y,g[i].x+n);
	}
	cout &lt;&lt;&quot;yes&quot;;
	return 0;
}
</code></pre>
<h5 id="关押罪犯">关押罪犯</h5>
<p>Description</p>
<p>S 城现有两座监狱，一共关押着 NNN 名罪犯，编号分别为 111 ~ NNN。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用 “怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 ccc 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 ccc 的冲突事件。</p>
<p>每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。</p>
<p>在详细考察了 NNN 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。</p>
<p>那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？</p>
<p>Input</p>
<p>输入第一行为两个正整数 N(1≤N≤20000)和 M(1≤M≤100000)，分别表示罪犯的数目以及存在仇恨的罪犯对数。</p>
<p>接下来的 M 行每行为三个正整数 aj,bj,a_j,b_j，表示 a_j​ 号和 b_j​ 号罪犯之间存在仇恨，其怨气值为 c_j​。数据保证 1&lt;aj,bj≤N1&lt;a_j, b_j \le N1&lt;aj​,bj​≤N，0&lt;cj≤1090 &lt; c_j \le 10^90&lt;cj​≤109，且每对罪犯组合只出现一次。</p>
<p>Output</p>
<p>输出共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 000。</p>
<p>Sample Input 1</p>
<p>4 6<br>
1 4 2534<br>
2 3 3512<br>
1 2 28351<br>
1 3 6618<br>
2 4 1805<br>
3 4 12884</p>
<p>Sample Output 1</p>
<p>3512</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 200100;
const int maxm = 100100;
struct node{
	int u,v;
	int s;
}e[maxm];

bool cmp(node a,node b){
	return a.s&gt;b.s;
}

int fa[maxn*2];
int n,m;
void init(){
	for(int i=1;i&lt;=2*n;i++){
		fa[i] = i;
	}
}

int get(int x){
	if(fa[x]!=x) fa[x]=get(fa[x]);
	return fa[x];
}

void merge(int x,int y)
{
    fa[get(x)] = get(y);
}
int main(){
	cin &gt;&gt; n &gt;&gt; m;
		init();
    	for(int i=1;i&lt;=m;i++){
    		cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].s;
		}
	sort(e+1,e+m+1,cmp);

for(int i=1;i&lt;=m;i++){
	if(get(e[i].u)==get(e[i].v)){
	   
		cout &lt;&lt; e[i].s;
		return 0;
	}else{
		merge(e[i].u,e[i].v+n);
		merge(e[i].u+n,e[i].v);
		
    } 
}
	cout &lt;&lt; &quot;0&quot;;
	return 0;
}
</code></pre>
<h5 id="接龙">接龙</h5>
<p><a href="http://120.77.248.79/problem/3033102">传送门</a></p>
<p>前缀差分思想，维护每个纸牌前面到底有多少纸牌的特性。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;

const int N=50100;
int n,m;
int fa[N];
int size[N],dist[N];

void init(){
    for(int i=0;i&lt;N;i++){
        fa[i]=i;
        size[i]=1;
        dist[i]=0;
    }
}

int get(int x){
    if(fa[x]==x){
        return x;
    }
    int y=fa[x];
    fa[x]=get(y);
    dist[x]+=dist[y];
    return fa[x];
}

void merge(int x,int y){
    x=get(x);
    y=get(y);
    if(x!=y){
        fa[x]=y;
        dist[x]=size[y];
        size[y]+=size[x];
    }
}
int main(){
	
    init();
    int n;
    cin&gt;&gt;n;
    
    while(n--){
        char op;
        int x,y;
        cin&gt;&gt;op&gt;&gt;x&gt;&gt;y;
        if(op=='M'){
            merge(x,y);
        }else{
            if(get(x)==get(y)){
                cout&lt;&lt;fabs(dist[x]-dist[y])-1&lt;&lt;endl;
            }else{
                cout&lt;&lt;&quot;-1&quot;&lt;&lt;endl;
            }
        }
    }
    return 0;
}
</code></pre>
]]></content>
    </entry>
</feed>