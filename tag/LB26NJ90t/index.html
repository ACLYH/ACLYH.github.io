<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="心之所向，素履以往，生如逆旅，一苇以航。">
<meta name="theme-color" content="#000">
<title>Lanthanum</title>
<link rel="shortcut icon" href="/favicon.ico?v=1632145389758">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>Lanthanum</span>
            </a>  
          
        </div>
        
          <p class="subtitle">心之所向，素履以往，生如逆旅，一苇以航。</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout  gemini">
      <div class="section-layout-wrapper">
        <div id="sidebarMeta" class="sidebar">
    
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">Lanthanum</p>
    
    <div class="site-description right-motion">
      
      
      
        <p>一个蒟蒻Oier的小站</p>
      
      
    </div>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">16</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
  
  



</div>
</div>
<script>
  let sidebarMeta = document.querySelector('#sidebarMeta');
  let scheme = 'gemini';
  let sidebarWrapper = document.querySelector('.sidebar-wrapper');
  if (sidebarMeta && (scheme === 'pisces' || scheme === 'gemini')) {
    document.addEventListener('scroll', function(e) {
      if (document.scrollingElement.scrollTop > parseInt(sidebarMeta.style.marginTop) + 10) {
        sidebarWrapper.classList.add('home-sidebar-fixed')
      } else {
        sidebarWrapper.classList.remove('home-sidebar-fixed')
      }
    });
  }
  </script>
        <div class="section-box tag-line box-shadow-wrapper">
          <section class="section tags-section posts-expand bg-color">
            <div class="padding-wrapper">
  <div class="tag-timeline-box">
    <div class="tag-timeline-wrapper">
      <div class="tag-timeline-title">
        <h2>
          最短路
          <small class="language" data-lan="tag">标签</small>
        </h2>
      </div>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      <a href="https://ACLYH.github.io/post/zui-duan-lu-suan-fa/">
        <div class="motion-warpper">
          <div class="tag-post-node">
            <h1>
              10-28
              <small>最短路算法</small>
            </h1>
          </div>
        </div>
      </a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
    </div>
  </div>
</div>
          </section>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = '';
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/ye-li/"" data-c="
          &lt;p&gt;12：25&lt;/p&gt;
&lt;p&gt;夜已深。&lt;/p&gt;
&lt;p&gt;看着窗外，昏黄的灯火，零星的几户未眠人家，不知停歇的红绿灯，在这万籁俱寂的夜里明明灭灭。&lt;/p&gt;
&lt;p&gt;稀疏，寂静的。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;浅浅的光在黑夜里挣扎着，不让昏暗吞噬那一抹渺小却温暖的灯火。&lt;/p&gt;
&lt;p&gt;风在窗外轻盈的舞动，拂过窗棂，顺着留下的浅浅缝隙灌进来，吹着窗帘，宛如鼓动的，洁白的衣袍。&lt;/p&gt;
&lt;p&gt;夜空并不是真正的黑色，而是莫名的昏黄，像画中的褐黄，调了淡淡的黑。是人间的倒映，将天光染上了昏黄的灯火。&lt;/p&gt;
&lt;p&gt;这段时间，仿佛是消失踪迹一般，昔日道路上的人影随风而散，亮如白昼的霓虹灯被夜色淡然掩盖，平日默默奔忙的公交车失了行迹，只剩下冬日落光了叶子的银杏在春夜慢慢发芽，似乎夜的风都带了淡淡的一丝清新。空旷而寂寥的夜里，失了往日的烟火，少了大街小巷的喧嚣，只剩下空茫的风顺着无一人的街道淡淡划过。留下寒冷的痕迹，映在同样冰冷的窗玻璃上。&lt;/p&gt;
&lt;p&gt;12:40。&lt;/p&gt;
&lt;p&gt;本就零星的灯火愈发稀疏，像天空的星辰被云雾遮住了光，匿在了茫茫黑夜。像一根灯心燃尽了蜡油，掐断了烛焰。像一缕发丝终于承受不起载着的千斤，猛然的断了。泼洒的墨水在一栋栋大楼上晕染开来，稀疏的光点如同渔舟驶进汹涌的海里，摇晃着，坠在浪里，落在夜里,溅起墨色的痕迹。&lt;/p&gt;
&lt;p&gt;1：10。&lt;/p&gt;
&lt;p&gt;灯影缥缈，树未眠。&lt;/p&gt;
&lt;p&gt;高楼里燃尽了灯火，只剩下黑梭梭的影子矗立在苍茫的夜里。露出隐隐约约轮廓，仿佛无声的雕塑，空洞的俯视着立足之地。但，那些昏黄的路灯依然散着飘渺不定的光。树影婆娑，在风中簇拥成浪，地面的光斑也跟着飘荡着，像河川上行着的渔舟，摇摇晃晃却永远亮着。驶过春风秋雨，夏月冬日。&lt;/p&gt;
&lt;p&gt;明明灭灭的光，立在路边，勾勒出一条在夜里看起来遥不可及亦真亦幻的路。怀着温暖的橘黄色，像希望。&lt;/p&gt;
&lt;p&gt;1：30。&lt;/p&gt;
&lt;p&gt;夜色彻底沉了下来，不似之前的昏黄，变得浓稠起来。没有星星，只剩下一望无际的黑，延续到天边，在天际与地平线化作一体，搅合着高楼的影子，浓的得再也化不开。只剩下那稀疏的路灯光汇聚成的路，浅浅的，却在这夜色里足以看得清，将天际与大地分出微微的不同。像雾中的指引，像混沌中的清明，像人间独有的烟火气。&lt;/p&gt;
&lt;p&gt;不知道什么时候，渐渐对黑夜萌生出了一丝好感。或是因为黑夜的宁静，或是黑夜包容了一切丑恶与不堪，或是它让白天忙碌的人们拥有了静下来的时光，亦或是，它收集起了灯火，收集起了光。光是常见的，亦是在白天随处可至的 。它们同太阳降临人间，给予万物于生机，拂去朦胧的水汽，带来人间以悲欢。它们随太阳而生，在黎明时给这一端带了灿烂与辉煌，又在日暮时放尽残阳的光辉。而夜，将这光小心的收集起来，凝聚成星空，倒映成人间烟火。白天随处可见的光，却成了黑夜的珍宝，在茫茫夜空中那么清晰。是白日里尚未消失殆尽的余光，是坚持在夜里留守的使者，它给予夜色，留下温暖的痕迹。&lt;/p&gt;
&lt;p&gt;星星的光从遥远的太空而来，离我们有多少光年，来到我们眼前，就要多少年。它们是远古而来的光，跨过了时空的桎梏，从千万年前奔来与我们相会。&lt;/p&gt;
&lt;p&gt;就像一条连接时空的纽带，从过去，到现在，去将来。&lt;/p&gt;
&lt;p&gt;我忽然想起，西方普罗米修斯为人类留下的火种，中国古代那些人们拼尽全力留下的薪火，远古人类冒着生命危险去雷击之地取来的天火。&lt;/p&gt;
&lt;p&gt;于他们而言，仿佛只是能带来温暖，带来光明，驱走黑夜与饥渴的野兽。&lt;/p&gt;
&lt;p&gt;然而，他们留下的火种，却燃烧起了人类长久的文明，不熄的光。&lt;/p&gt;
&lt;p&gt;1：50&lt;/p&gt;
&lt;p&gt;记起小时候，晚上玩耍回家迟了，而走在楼下，一抬头终总会看到一抹未熄的灯光在等着我。&lt;/p&gt;
&lt;p&gt;小时候怕黑，不愿关上卧室的门，注视着客厅溜出来的光，渐渐沉入梦乡。或者有时候打了雷，外公总在窗外雷声乍起时踏进来，陪着我，让我不要怕，让我可以看到他眼镜片的反光。&lt;/p&gt;
&lt;p&gt;或者以前过年，爸爸妈妈带来一捆烟火，让我看着一抹流光绚丽的火花绽放。&lt;/p&gt;
&lt;p&gt;夏日在一荷花池中钓虾，看着饵落入水中荡开涟漪，又在拉上一只虾时溅起水花。荷花盛开，清风送香，水光潋滟，葳蕤生光。&lt;/p&gt;
&lt;p&gt;那年去上海参赛，一日空闲，随同学老师走走上海滩。那日下着细雨，撑起一把把伞，在黄埔江边看东方明珠塔。但雨云却遮了一大半，看不真切，略干感失望。然而晚上，我们却都收到老师发来的一张照片。躺在床上，突然翻到一张东方明珠塔的夜景。带着霓虹，在黑沉沉的夜里那样璀璨，像模糊而又微微清晰的未来，很美。她一个人在晚上来的江边，留下了这张照片，也留下了烙印在我们心中的印记。像华光璀璨的东方明珠塔，是霓虹的颜色。&lt;/p&gt;
&lt;p&gt;那个暑假在海南的一座小岛。那天有些不幸，刮了大风，停了电。一行人拿着蜡烛，坐在天台上，闲聊。那日有月亮，有漫入眼睛的星星。遥不可及，却又那样真实，仿佛垂手可得。从那里可以隐隐约约的看到海，耳边听着微小的海浪声，吹着天台上吹来的风，看着蜡烛的火摇曳着燃烧。旅人谈论着过几天要去哪里，或是亲人们闲聊着家常。那些旅人对我们来说只不过是萍水相逢，却依然东扯一句，西来一句的交谈着。明明是不久就要分别的人们，却让我多希望时光能停下来，留存在那一刻。星星似乎离我们好远，像时光，是暖暖的，却又无法阻拦他运行的轨迹，只能默默看着它画出永恒的图谱。&lt;/p&gt;
&lt;p&gt;也有不久前在泰国的一座小岛上，入夜，仰望天空，满天繁星沉沉入目。很久没有看见过如此之多的星辰了。记忆还是在儿时，仲夏故乡的院坝里，坐在躺椅里，沉甸甸的摇晃着蒲扇，听着虫鸣与老人絮絮叨叨的古老故事相呼应。抬头便是辽阔的夜空，微微泛紫，嵌着数不清的星辰。&lt;/p&gt;
&lt;p&gt;那些在黑夜里微微发亮的光，在记忆里构成了一条宽广的河，仿佛苍穹携着银河，那些关于光的记忆，便在星空的波涛里沉沉浮浮。&lt;/p&gt;
&lt;p&gt;2：20。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;!-- more --&gt;
">夜里</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/2020csp-s/"" data-c="
          &lt;iframe frameborder=&#34;no&#34; border=&#34;0&#34; marginwidth=&#34;0&#34; marginheight=&#34;0&#34; width=330 height=86 src=&#34;//music.163.com/outchain/player?type=2&amp;id=1368398851&amp;auto=1&amp;height=66&#34;&gt;&lt;/iframe&gt;
&lt;h4 id=&#34;2020-11-04&#34;&gt;2020-11-04&lt;/h4&gt;
&lt;p&gt;还有3天CSP-S，AFO。&lt;br&gt;
&lt;s&gt;这边准备好AFO了&lt;/s&gt;&lt;/p&gt;
">2020CSP-S</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/10-31-bao-ling-ji/"" data-c="
          &lt;p&gt;&lt;s&gt;11月7日提高组，我怎么觉得我要炸呢&lt;/s&gt;&lt;/p&gt;
&lt;h4 id=&#34;t1互不攻击的炮&#34;&gt;T1:互不攻击的炮&lt;/h4&gt;
&lt;p&gt;(canon.cpp/in/out 1s 128M)&lt;br&gt;
在一个 N 行 M 列的棋盘上，让你放若干个炮（可以是 0 个），使得没有一个炮可以攻击到&lt;br&gt;
另一个炮，请问有多少种放置方法。大家肯定很清楚，在中国象棋中炮的行走方式是：一个&lt;br&gt;
炮攻击到另一个炮，当且仅当它们在同一行或同一列中，且它们之间恰好有一个棋子。你也&lt;br&gt;
来和小可可一起锻炼一下思维吧！&lt;br&gt;
输入&lt;br&gt;
一行包含两个整数 N，M，之间由一个空格隔开。 N 和 M 均不超过 6&lt;br&gt;
输出&lt;br&gt;
总共的方案数，由于该值可能很大，只需给出方案数模 9999973 的结果。&lt;br&gt;
样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入
1 3
输出
7
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提示&lt;br&gt;
除了 3 个格子里都塞满了炮以外，其它方案都是可行的，所以一共有 2&lt;em&gt;2&lt;/em&gt;2-1=7 种方案。&lt;/p&gt;
&lt;p&gt;简单的DFS，由题可知，每一行和每一列的棋子个数都不会超过2个，一个一个格子判断。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m;
int sx[1010000],sy[1010000];
int ans = 0;
void dfs(int x,int y){
	if(x==n+1&amp;amp;&amp;amp;y==1){
		ans++;
//		ans%=9999973;
		return ;
	}
	if(sx[x]&amp;lt;2&amp;amp;&amp;amp;sy[y]&amp;lt;2){
		sx[x]++;
		sy[y]++;
		if(y==m)dfs(x+1,1);
		else dfs(x,y+1);
		sx[x]--;
		sy[y]--;
		if(y==m){
			dfs(x+1,1);
		}else{
			dfs(x,y+1);
		}
	}else{
		if(y==m){
			dfs(x+1,1);
		}else{
			dfs(x,y+1);
		}
	}
	
}
int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;m;
	dfs(1,1);
	cout &amp;lt;&amp;lt; ans;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;T2 Photography&lt;/p&gt;
&lt;p&gt;农夫 John（以后简称“FJ”）的 N 头奶牛站在一个一维长篱笆上的不同位置 (1 &amp;lt;= N &amp;lt;=&lt;br&gt;
100,000)。第 i 头奶牛站在位置 x_i (一个处于范围 0...1,000,000,000 的整数)，其品种为 b_i&lt;br&gt;
（要么为‘G’，表示根西种 Guernsey，要么为‘H’，表示霍斯坦种 Holstein）。每头奶牛的位置&lt;br&gt;
各不相同。FJ 想要为一段连续区间内的奶牛拍张照片，用来参加郡里的展览会，但是他想让&lt;br&gt;
照片里各个品种奶牛的数量是“公平的”。所以，他想要使得无论照片里出现了多少个品种的&lt;br&gt;
奶牛，这些品种奶牛的数量必须相同（例如，一张照片里可以全是霍斯坦种奶牛，也可以出&lt;br&gt;
现 27 头根西种奶牛和 27 头霍斯坦种奶牛，但不能出现 10 头霍斯坦种奶牛和 9 头根西种奶&lt;br&gt;
牛，这种情况下各个品种数量不同）。帮助 FJ 拍一张满足其要求的最大尺寸照片。一张照片&lt;br&gt;
的尺寸为照片中最左边的奶牛和最右边的奶牛的位置差。可能 FJ 拍出的照片里只有一头奶&lt;br&gt;
牛，此时照片的尺寸为 0。&lt;br&gt;
输入&lt;br&gt;
第 1 行：整数 N。&lt;br&gt;
第 2..1+N 行：第 i+1 行包含 x_i 和 b_i。&lt;br&gt;
输出&lt;br&gt;
第 1 行：一个整数，表示一张“公平的”照片的最大尺寸。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;样例输入
6
4 G
10 H
7 G
16 G
1 G
3 H
【输入说明】
有 6 头奶牛（从左到右）品种分别为 G, H, G, G, H, G。
样例输出
7
【输出说明】
FJ 可以拍出的最大尺寸“公平的”照片是出现中间 4 头奶牛的照片，包括了 2 头霍斯坦种奶牛
和 2 头根西种奶牛。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;前缀和。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=1e5+10;
int n;
int exnn[maxn];
struct cow{
	int x,op;
}a[maxn];

bool cmp(const cow &amp;amp;a,const cow &amp;amp;b){
	return a.x&amp;lt;b.x;
}
bool check(int x){
	int r=0;
	for(int l=1;l&amp;lt;=n;l++) {				
		while(a[r].x-a[l].x&amp;lt;x&amp;amp;&amp;amp;r&amp;lt;n)r++;
		if(a[r].x-a[l].x&amp;lt;x)break;		
		if(exnn[r]-exnn[l-1]&amp;gt;=0&amp;amp;&amp;amp;(exnn[r]-exnn[l-1])%2==0){
			return true;
		}
	}
	return 0;
}
int main(){
	cin &amp;gt;&amp;gt; n;
	for(int i=1;i&amp;lt;=n;i++){
		char op[2];
		cin &amp;gt;&amp;gt; a[i].x&amp;gt;&amp;gt;op;
		if(op[0]==&#39;H&#39;)a[i].op=1;
		else a[i].op=-1;
	}
	sort(a+1,a+1+n,cmp);
	for(int i=1;i&amp;lt;=n;i++){
		exnn[i]=exnn[i-1]+a[i].op;
	}
	int lb=0,ub=0x3f3f3f3f;
	while(ub-lb&amp;gt;1){
		int mid=(lb+ub)&amp;gt;&amp;gt;1;
		if(check(mid))lb=mid;
		else ub=mid;
	}
	cout&amp;lt;&amp;lt;lb&amp;lt;&amp;lt;endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">10-31爆零记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/zui-xiao-sheng-cheng-shu-mo-ban/"" data-c="
          &lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出orz&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;输入输出格式&lt;br&gt;
输入格式：&lt;/p&gt;
&lt;p&gt;第一行包含两个整数N、M，表示该图共有N个结点和M条无向边。（N&amp;lt;=5000，M&amp;lt;=200000）&lt;/p&gt;
&lt;p&gt;接下来M行每行包含三个整数Xi、Yi、Zi，表示有一条长度为Zi的无向边连接结点Xi、Yi&lt;/p&gt;
&lt;p&gt;输出格式：&lt;/p&gt;
&lt;p&gt;输出包含一个数，即最小生成树的各边的长度之和；如果该图不连通则输出orz&lt;/p&gt;
&lt;p&gt;输入输出样例&lt;br&gt;
输入样例#1：&lt;/p&gt;
&lt;p&gt;4 5&lt;br&gt;
1 2 2&lt;br&gt;
1 3 2&lt;br&gt;
1 4 3&lt;br&gt;
2 3 4&lt;br&gt;
3 4 3&lt;/p&gt;
&lt;p&gt;输出样例#1：&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;数据规模：&lt;/p&gt;
&lt;p&gt;对于20%的数据：N&amp;lt;=5，M&amp;lt;=20&lt;/p&gt;
&lt;p&gt;对于40%的数据：N&amp;lt;=50，M&amp;lt;=2500&lt;/p&gt;
&lt;p&gt;对于70%的数据：N&amp;lt;=500，M&amp;lt;=10000&lt;/p&gt;
&lt;p&gt;对于100%的数据：N&amp;lt;=5000，M&amp;lt;=200000&lt;/p&gt;
&lt;p&gt;样例解释：&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190609135251535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以最小生成树的总边权为2+2+3=7&lt;/p&gt;
&lt;p&gt;并查集&lt;br&gt;
既然最小，那么重载cmp函数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m;
struct node{
    int u;
    int w;
    int v;
}g[1110000];
bool cmp(node a,node b){
    return a.w&amp;lt;b.w;
}
int fa[10010];
void init(){
    for(int i=1;i&amp;lt;=n;i++){
        fa[i]=i;
    }
}
int get(int x){
    if(fa[x]==x){
        return x;
    }else{
        int y=get(fa[x]);
        fa[x]=y;
        return y;
    }
}
int main(){
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m;
    for(int i=1;i&amp;lt;=m;i++){
        cin&amp;gt;&amp;gt;g[i].u&amp;gt;&amp;gt;g[i].v&amp;gt;&amp;gt;g[i].w;
    }
    init();
    sort(g+1,g+1+m,cmp);
    int ans=0;
    for(int i=1;i&amp;lt;=m;i++){
        if(get(g[i].u)!=get(g[i].v)){
            ans+=g[i].w;
            fa[get(g[i].u)]=get(g[i].v);
        }
    }
    cout&amp;lt;&amp;lt;ans;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">最小生成树模板</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/zui-duan-lu-dan-yuan/"" data-c="
          &lt;p&gt;Dijkstra算法和SPFA算法用于求单源最短路。&lt;br&gt;
最短路就是求两点之间的最短路径。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;最短路径怎么求呢？&lt;br&gt;
更新就是了（松弛）。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190419201104445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;先赋予厚望（先假设无穷大）&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190419201303886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;然后依次更新&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190419202104933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过起点1来比较哪条路到终点20最短&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190419202225404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;暂时选择这条绿色的路&lt;br&gt;
继续比较&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190419202710202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所以蓝色的路是最短的。&lt;br&gt;
然后看一道纯模板题。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;骑车比赛

Description

小信准备去参加骑车比赛，比赛在 n 个城市间进行，编号从 1 到 n。选手们都从城市 1 出发，终点在城市 n。

已知城市间有 m 条道路，每条道路连接两个城市，注意道路是双向的。现在小信知道了他经过每条道路需要花费的时间，他想请你帮他计算一下，他这次比赛最少需要花多少时间完成。

Input

第一行输入两个整数 n,m（1≤n≤1,000,1≤m≤5,000），分别代表城市个数和道路总数。接下来输入 m 行，每行输入三个数字 a,b,c（1≤a,b≤n,1≤c≤200），分别代表道路的起点和道路的终点，以及小信骑车通过这条道路需要花费的时间。保证输入的图是连通的。

Output

输出一行，输出一个整数，输出小信完成比赛需要的最少时间。

Sample Input 1

5 6
1 2 2
2 3 3
2 5 5
3 4 2
3 5 1
4 5 1

Sample Output 1

6


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;典型的最短路&lt;br&gt;
Dijkstra模板：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;


int n,m;

struct node{//结构体
	int v,w;
	node(){ };
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[10100];

bool vis[10100];
int dst[10100];

void add(int u,int v,int w){//建图
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){
	memset(dst,0x3f,sizeof dst);
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&amp;lt;g[u].size();j++){
			
			int v = g[u][j].v;
			int w = g[u][j].w;
			dst[v] = min(dst[v],dst[u]+w);
			
		}
		
		int mi=0x3f3f3f3f;//无穷大
		for(int j=1;j&amp;lt;=n;j++){
			if(!vis[j]&amp;amp;&amp;amp;mi&amp;gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}
}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;m;
	int u,v,w;
	while (m--){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
		add(u,v,w);
	}
	
	dij(1);
	cout &amp;lt;&amp;lt; dst[n];
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SPFA模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=1010;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[maxn];
int dst[maxn];
queue &amp;lt;int&amp;gt; qu;
int inq[maxn];

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}

void spfa(int s){
	memset(dst,inf,sizeof dst);
	int u=s;
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&amp;lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&amp;gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	int u , v , w; 
	while (m--){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
		add(u,v,w);
	}
	spfa(1);
	cout &amp;lt;&amp;lt; dst[n]&amp;lt;&amp;lt;endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;迷阵突围

Description

小信陷入了坐标系上的一个迷阵，迷阵上有 n个点，编号从 1 到 n。小信在编号为 1 的位置，他想到编号为 n 的位置上。小信当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在小信知道了 n 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

注意，每条路径上不能重复经过同一个点。

Input

第一行输入两个整数 n (1≤n≤200) 和 m，表示一共有 n 个点和 m 条边。

接下来输入 n 行，每行输入两个整数 xi,yi (−500≤xi,yi≤500)，代表第 i 个点的坐标。

接下来输入 m 行，每行输入两个整数 pj,qj (1≤pj,qj≤n)，表示点 pj 和点 qj 之间相连。

Output

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 -1。

Sample Input 1

3 3
1 1
2 2
3 2
1 2
2 3
1 3

Sample Output 1

2.41


&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模板改进。（两个dij函数）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int n,m;

struct node{
	int v;
	double w;
	node(){ };
	node(int _v,double _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[10100];

bool vis[10100];
double dst[10100];

int x[10100],y[10100];
int pre[10100];
void add(int u,int v,double w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){

	memset(vis,0,sizeof vis);
	for(int i=1;i&amp;lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&amp;lt;g[u].size();j++){
			
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(dst[v]&amp;gt;dst[u]+w){
				dst[v]=dst[u]+w;
				pre[v]=u;
			}
		}
		
		double mi=1e20;
		for(int j=1;j&amp;lt;=n;j++){
			if(!vis[j]&amp;amp;&amp;amp;mi&amp;gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}

}


void dij2(int s,int uu,int vv){
	
	memset(vis,0,sizeof vis);
	for(int i=1;i&amp;lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&amp;lt;g[u].size();j++){
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(uu ==u &amp;amp;&amp;amp; vv==v || uu==v &amp;amp;&amp;amp; vv == u){
				continue;
			}
	
			dst[v] = min(dst[v],dst[u]+w);

	}
		double mi=1e20;
		for(int j=1;j&amp;lt;=n;j++){
			if(!vis[j]&amp;amp;&amp;amp;mi&amp;gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	 
	}

}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;m;
	int u,v;
	double w;
	
	for(int i=1;i&amp;lt;=n;i++){
		cin &amp;gt;&amp;gt; x[i] &amp;gt;&amp;gt;y[i];
	}
	
	while (m--){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
		w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
		add(u,v,w);
	}
	
	dij(1);

	
	double mi=1e20;
	for(int i=n;pre[i]!=0;i=pre[i]){
		dij2(1,i,pre[i]);
		mi=min(mi,dst[n]);
	}
	     if(mi == 1e20){
	      cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot;&amp;lt;&amp;lt;endl;
		 }else{
			 cout&amp;lt;&amp;lt;fixed&amp;lt;&amp;lt;setprecision(2)&amp;lt;&amp;lt;mi&amp;lt;&amp;lt;endl;
		}
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">最短路（单源）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/er-fen-cha-zhao-fa/"" data-c="
          &lt;p&gt;二分查找法是从区间[i，j]上连续不断将sum（a）·sum（b）&amp;lt;0的函数ans=sum（x），通过循环实现把函数sum（x）的0点所在区间一分为二，如此循环，使区间[i,j]的两个端点逐渐像0点靠近，得到0点近似值的方法。可以实现空间优化，适用于数据较大的题目。时间复杂第O（log（2n））。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;在使用c++的二分查找法，要先将数据排序，二分查找法的基本思想可以这样总结：我们设数据是按升序排序的，根据题目中的数a，从序列的中间进行二分，如果当前i位置值等于a，则停止查找 ；假如a小于当前位置i，则在数列的前部分中查找；若a大于当前位置i，就在数列的后段进行查找，如果还没找到，再次二分，直到找到了a值。&lt;/p&gt;
&lt;p&gt;二分例题：&lt;/p&gt;
&lt;p&gt;小信的猜想&lt;br&gt;
Description&lt;br&gt;
有一天小信突发奇想，他有一个猜想，任意一个大于 2 的偶数好像总能写成 2 个质数的和。小信查了资料，发现这个猜想很早就被一个叫哥德巴赫的人提出来了，称为哥德巴赫猜想。目前还没有证明这个猜想的正确性。小信告诉你一个整数 n ，让你用这个数去验证。注意 1 不是质数。&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入一个偶数 n(2&amp;lt;n≤8000000)。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;输出一个整数表示有多少对 (x,y) 满足 x+y=n(x≤y) 且 x,y 均为质数。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;br&gt;
6&lt;br&gt;
Sample Output 1&lt;br&gt;
1&lt;br&gt;
Sample Input 2&lt;br&gt;
10&lt;br&gt;
Sample Output 2&lt;br&gt;
2&lt;br&gt;
——摘自YCOJ&lt;br&gt;
对，是一道哥德巴赫猜想。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int a[9000000];
bool b[9000000];
int main(){
	int n,cnt=0,k=0;
	cin &amp;gt;&amp;gt; n;
	for(int i=2;i&amp;lt;n;i++){
		if(b[i]==0){
		 for(int j=i+i;j&amp;lt;n;j+=i){
			b[j]=1;
		}
		a[k]=i;
		k++;
	}
}
	for(int i=0;i&amp;lt;k;i++){
			//查找 
			int tmp = n-a[i];
			
			int l=i,r=k-1,mid;
			while(r-l&amp;gt;1){
				mid=(l+r)/2;
				if(a[mid]&amp;lt;tmp){
					l=mid+1;
				}else{
					r=mid;
				}
			}
			if(a[l] == tmp || a[r]==tmp){
				cnt++;
			}
		}
	cout &amp;lt;&amp;lt; cnt;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这道题就运用到了二分查找法，正片程序可以看做两部分，一边是主程序，一边是二分查找法的实现，用&lt;code&gt;while(r-l&amp;gt;1)&lt;/code&gt;比较并循环，判断数据是在上半部分还是下半部分，再用&lt;code&gt;mid=(l+r)/2;&lt;/code&gt;进行折半查找。&lt;/p&gt;
&lt;h4 id=&#34;查找&#34;&gt;查找&lt;/h4&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;给出一个有 n 个元素的数列 a 和两个整数 k 和 s，其中数列 a 的元素是按照升序排列的。&lt;/p&gt;
&lt;p&gt;请你在数列中找出一个元素 x，使得的 x+k=s。&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入第一行一个整数 n(1≤n≤10^5)，表示数列中的元素个数。&lt;/p&gt;
&lt;p&gt;接下来一行输入 n 个空格隔开的整数，表示输入的数列 a，保证是升序排列，并且 −10&lt;sup&gt;9≤ai≤10&lt;/sup&gt;9。&lt;/p&gt;
&lt;p&gt;接下来一行输入两个整数 k,s(−10&lt;sup&gt;9≤k,s≤10&lt;/sup&gt;9)。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;如果能找到满足条件的数，输出&amp;quot;Yes&amp;quot;，否者输出&amp;quot;No&amp;quot;。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;5&lt;br&gt;
1 2 3 4 5&lt;br&gt;
-1 4&lt;br&gt;
Sample Output 1&lt;/p&gt;
&lt;p&gt;Yes&lt;br&gt;
——摘自YCOJ&lt;br&gt;
题目中给出了，一个重要词——升序排列，所以我们可以看出，这道题应该用二分查找法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main () {
  int n;
  cin &amp;gt;&amp;gt; n;
  int a[n];
  for(int i = 0; i &amp;lt; n; i++){
  	cin &amp;gt;&amp;gt; a [i];
  }
  int k, s;
  cin &amp;gt;&amp;gt; k &amp;gt;&amp;gt; s;
  int l = 0, r = n,x = s-k;
  int mid;
  while(l &amp;lt; r ){
  	int mid=(l+r)/2;
  	if (a[mid]&amp;lt;x){
  	  l = mid + 1;
  }else{
	  r=mid;
	}
  }
  

	if(a[l]==x||a[r]==x) {
		cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
	}
	else {
		cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; ;
	}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;两数之和&#34;&gt;两数之和&lt;/h4&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;给出一个有 n 个元素的数列 a 和一个整数 s，其中数列 a 的元素是按照升序排列的。&lt;/p&gt;
&lt;p&gt;请你在数列中找出两个元素 x,y使得的 x+y=s。&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入第一行一个整数 n(1≤n≤10^5)，表示数列中的元素个数。&lt;/p&gt;
&lt;p&gt;接下来一个输入 n 个空格隔开的整数，表示输入的数列 a，保证是升序排列，并且 −10&lt;sup&gt;9≤ai≤10&lt;/sup&gt;9。&lt;/p&gt;
&lt;p&gt;接下来一行输入一个整数 s(−10&lt;sup&gt;9≤x,s≤10&lt;/sup&gt;9)。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;如果能找到满足条件的两个数，输出&amp;quot;Yes&amp;quot;，否者输出&amp;quot;No&amp;quot;。&lt;br&gt;
——摘自YCOJ&lt;br&gt;
Sample Input 1&lt;/p&gt;
&lt;p&gt;5&lt;br&gt;
1 2 3 4 5&lt;br&gt;
4&lt;br&gt;
Sample Output 1&lt;/p&gt;
&lt;p&gt;Yes&lt;br&gt;
Sample Input 2&lt;/p&gt;
&lt;p&gt;5&lt;br&gt;
1 2 4 4 5&lt;br&gt;
4&lt;br&gt;
Sample Output 2&lt;/p&gt;
&lt;p&gt;No&lt;br&gt;
同样的，二分查找。单独用两层for循环枚举是要超时的。&lt;br&gt;
——摘自YCOJ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int a[1000010];
int main(){
	 int  n;
	 cin &amp;gt;&amp;gt; n;
	 int ans=0;
	 for(int i=1;i&amp;lt;=n;i++){
	 	cin &amp;gt;&amp;gt; a[i];
	 }
	 int s;
	 cin &amp;gt;&amp;gt; s;
	 for(int i=1;i&amp;lt;=n;i++){
	 		int l =1, r = n, x = s - a [i];
			while(r-l&amp;gt;1){
			int	min=(l+r)/2;
				if(a[min]&amp;lt;x){
					l=min+1;
				}else{
					r=min;
				}
			}
			if(a[l] == x ||a[r]==x){
				ans++;
			}
		}
if (ans&amp;gt;1) {
  cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot; &amp;lt;&amp;lt; endl;
  }else {
  cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt; endl;
}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;割绳子&#34;&gt;割绳子&lt;/h4&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;现有 N 条绳子，它们的长度分别为 L1，L2，……，Ln，如果从它们中切割出 K 条长度相同的绳子，这 K 条绳子每条最长能有多长?&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入共有两行，第一行包含两个正整数 N 和 K（1≤N≤1000，1≤K≤1000），用一个空格分隔；第二行包含 N 个数，依次表示 N 条绳子的长度，两数间用一个空格分隔。每条绳子的长度的小数不超过两位（1≤Li≤10000）。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;输出仅包含一个数，表示所得 K 条绳子的最大长度。答案四舍五入保留小数点后两位。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;4 11&lt;br&gt;
8.02 7.43 4.57 5.39&lt;br&gt;
Sample Output 1&lt;/p&gt;
&lt;p&gt;2.01&lt;br&gt;
——摘自YCOJ&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
double a[10000001];
int n,k;
int mid(double l){
	int ans=0;
	for(int i=0;i&amp;lt;n;i++){
		ans+=a[i]/l;
	}
	return ans;
}


int main(){
	double mim;
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
	
	for(int i=0;i&amp;lt;n;i++){
		cin &amp;gt;&amp;gt; a[i];
		mim = max(mim,a[i]); 
	}
	
	double l = 0,m;
	double r=mim;
	while (r-l&amp;gt;=1e-9){       
		m=(l+r)/2;
		if(mid(m)&amp;gt;=k){
			l=m;
		}else{
			r=m;
		}
	}
	printf(&amp;quot;%.2lf&amp;quot;,m);
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;切割钢管&#34;&gt;切割钢管&lt;/h4&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;小白在工地干活。工地现有 nn 根钢管，第 ii 根钢管的长度为 a_ia&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
。&lt;/p&gt;
&lt;p&gt;现在小白想用这 nn 根钢管来做一个支撑用的柱子。工人可以切割这些钢管成为更短的钢管，但是不能缝合两根钢管。为了安全起见，柱子必须用 至少 kk 根长度相同的钢管加上混凝土制成，并且要求钢管长度必须为 整数。&lt;/p&gt;
&lt;p&gt;小白想知道，这个柱子最高能建成多高。&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入第一行一个整数 n, k (1 \le n, k \le 10000)n,k(1≤n,k≤10000)。&lt;/p&gt;
&lt;p&gt;接下来一行输入 nn 个空格隔开的整数 a_i(1 \le l_i \le 10^8)a&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
(1≤l&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
≤10&lt;br&gt;
8&lt;br&gt;
)，表示每根钢管的长度。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;输出能够得到的柱子最大高度。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;2 4&lt;br&gt;
8 4&lt;br&gt;
Sample Output 1&lt;/p&gt;
&lt;p&gt;2&lt;br&gt;
Sample Input 2&lt;/p&gt;
&lt;p&gt;8 8&lt;br&gt;
12 3 14 12 14 20 4 8&lt;br&gt;
Sample Output 2&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int a[1000010];
int n,k;
int cnt(int len){
	int ans=0;
	for (int i=0;i&amp;lt;n;i++){ 
		ans +=a[i]/len;
	}
	return ans;
}
int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
 int mx=0;
	for (int i=0;i&amp;lt;n;i++){
		cin &amp;gt;&amp;gt; a[i];
      mx=max(mx,a[i]);
	}
	int l=0,r=mx,x;
	while (r-l &amp;gt; 1){
		x=(l+r)/2;
		if (cnt(x)&amp;gt;=k){
			l = x;
		}
		else {
			r = x - 1;
		}
	}
	
    if(cnt(r) &amp;lt; k){
    	r=l;
	}
	cout &amp;lt;&amp;lt; r;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;火车站台连锁店&#34;&gt;火车站台连锁店&lt;/h4&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;蒜头君建立了一家火车站台连锁店，要在一条铁路线的所有车站里，选择一部分车站开办连锁店，销售各种口味的大蒜。&lt;/p&gt;
&lt;p&gt;铁路线上有 nn 个车站，假设这条铁路线是一条直线，其中每个站点的坐标为 x_1,x_2,\ldots,x_nx&lt;br&gt;
1&lt;br&gt;
​	&lt;br&gt;
,x&lt;br&gt;
2&lt;br&gt;
​	&lt;br&gt;
,…,x&lt;br&gt;
n&lt;br&gt;
​	&lt;br&gt;
。&lt;/p&gt;
&lt;p&gt;蒜头君一共要开办 mm 个连锁店，并且不希望连锁店离得太近，以使得整体的收益最大化。他希望他的连锁店之间的最近距离尽可能大，你能帮他算出这个最大的最近距离吗？&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;第一行输入用空格分隔的两个整数 n,m(2 \10^5, 2 \ m  n)n,m(2≤n≤10&lt;br&gt;
5&lt;br&gt;
,2≤m≤n)，分别表示车站数量和连锁店数量。&lt;/p&gt;
&lt;p&gt;接下来一共 nn 行，每行一个整数 x_i{0 \leq x_i \leq 10^9}x&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
0≤x&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
≤10&lt;br&gt;
9&lt;br&gt;
，表示车站的坐标。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;输出一行整数，表示最大的最近距离。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;6 3&lt;br&gt;
1&lt;br&gt;
3&lt;br&gt;
5&lt;br&gt;
2&lt;br&gt;
7&lt;br&gt;
9&lt;br&gt;
Sample Output 1&lt;/p&gt;
&lt;p&gt;4&lt;br&gt;
Sample Input 2&lt;/p&gt;
&lt;p&gt;5 4&lt;br&gt;
5&lt;br&gt;
7&lt;br&gt;
10&lt;br&gt;
28&lt;br&gt;
9&lt;br&gt;
Sample Output 2&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt; 
using namespace std;
int a[1000010];
int n,m;
int cnt(int len){
	int tot=1;
	int last = 0;
	for(int i = 1;i&amp;lt;n;i++){
		if(a[i] - a[last] &amp;gt;= len){
		   	tot++;
			last = i;
        }
    }
	return tot;
}
int main (){ 
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	for(int i=0;i&amp;lt;n;i++){
		cin &amp;gt;&amp;gt; a[i];
	}
	sort(a,a+n);
	int l=0,r=a[n - 1],ans;
	while (r - l &amp;gt; 1){
	    ans=(l+r)/2;
		if (cnt(ans) &amp;gt;= m){
			l = ans;
	    }
		else{
			r = ans;
		}
	}
	if(cnt(r)&amp;lt;m){
		r = l;
	}
	cout &amp;lt;&amp;lt; r;
	return 0; 
}
&lt;/code&gt;&lt;/pre&gt;
">二分查找法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/zui-duan-lu-suan-fa/"" data-c="
          &lt;h4 id=&#34;1dijkstra&#34;&gt;1.Dijkstra&lt;/h4&gt;
&lt;p&gt;Dijkstra用于计算一个顶点到其他所有顶点的最短路径。Dijkstra 算&lt;br&gt;
法的主要特点是以起点为中心，逐层向外扩展一个点，每次都会取一个最近点继续扩展，直到取完所有点为止。但Dijkstra 算法要求图中不能出现负权边。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;//模板
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;


int n,m;

struct node{
	int v,w;
	node(){ };
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[10100];

bool vis[10100];
int dst[10100];

void add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){
	memset(dst,0x3f,sizeof dst);
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&amp;lt;g[u].size();j++){
			
			int v = g[u][j].v;
			int w = g[u][j].w;
			dst[v] = min(dst[v],dst[u]+w);
			
		}
		
		int mi=0x3f3f3f3f;
		for(int j=1;j&amp;lt;=n;j++){
			if(!vis[j]&amp;amp;&amp;amp;mi&amp;gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}
}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;m;
	int u,v,w;
	while (m--){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
		add(u,v,w);
	}
	
	dij(1);
	cout &amp;lt;&amp;lt; dst[n];
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2spfa&#34;&gt;2.SPFA&lt;/h4&gt;
&lt;p&gt;SPFA算法是单源最短路径的一种算法，通常被认为是 Bellmanford算法的队列优化，在代码形式上接近宽度优先搜索 BFS，是一个在实践中非常高效的单源最短路算法。它会在每次更新了最短路以后又重新入队从而去更新后续结点的最短路。同时有些题有卡SPFA的数据，所以也可以换成Dijkstra。但Dijkstra 不能处理有负权的图，而 SPFA 可以处理不含负环的图的最短路，并能 判断是否存在负环。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//模板
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=1010;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[maxn];
int dst[maxn];
queue &amp;lt;int&amp;gt; qu;
int inq[maxn];

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}

void spfa(int s){
	memset(dst,inf,sizeof dst);
	int u=s;
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&amp;lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&amp;gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
				}
			}
		}
	}
}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	int u , v , w; 
	while (m--){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
		add(u,v,w);
	}
	spfa(1);
	cout &amp;lt;&amp;lt; dst[n]&amp;lt;&amp;lt;endl;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;floyd&#34;&gt;Floyd&lt;/h4&gt;
&lt;p&gt;基于动态规划思想，个人认为Floyd较Dijkstra和SPFA更难理解，所以就不写太多，但代码很短。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int N = 1e2 + 9;
const int inf = 0x3f3f3f3f;
int mp[N][N];
void floyd(int n) {
	for (int k = 1; k &amp;lt;= n; ++k) {
		for (int i = 1; i &amp;lt;= n; ++i) {
			for (int j = 1; j &amp;lt;= n; ++j) {
				mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
			}
		}
	}
}
int main() {
	memset(mp, inf, sizeof mp);
	for (int i = 0; i &amp;lt; N; ++i) {
		mp[i][i] = 0;
	}
int n, m;
int u, v, w;
cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	while (m--) {
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v &amp;gt;&amp;gt; w;
		mp[u][v] = mp[v][u] = w;
	}
	floyd(n);
	for (int i = 1; i &amp;lt;= n; ++i) {
		for (int j = 1; j &amp;lt;= n; ++j) {
			cout &amp;lt;&amp;lt; mp[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
		}
		cout &amp;lt;&amp;lt; endl;
	}
return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;一些最短路的题目&#34;&gt;一些最短路的题目&lt;/h4&gt;
&lt;h5 id=&#34;1迷阵突围&#34;&gt;1.迷阵突围&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;

Description

小信陷入了坐标系上的一个迷阵，迷阵上有 n个点，编号从 1 到 n。小信在编号为 1 的位置，他想到编号为 n 的位置上。小信当然想尽快到达目的地，但是他觉得最短的路径可能有风险，所以他会选择第二短的路径。现在小信知道了 n 个点的坐标，以及哪些点之间是相连的，他想知道第二短的路径长度是多少。

注意，每条路径上不能重复经过同一个点。

Input

第一行输入两个整数 n (1≤n≤200) 和 m，表示一共有 n 个点和 m 条边。

接下来输入 n 行，每行输入两个整数 xi,yi (−500≤xi,yi≤500)，代表第 i 个点的坐标。

接下来输入 m 行，每行输入两个整数 pj,qj (1≤pj,qj≤n)，表示点 pj 和点 qj 之间相连。

Output

输出一行，输出包含一个数，表示第二短的路径长度（小数点后面保留两位），如果第一短路径有多条，则答案就是第一最短路径的长度；如果第二最短路径不存在，则输出 -1。

Sample Input 1

3 3
1 1
2 2
3 2
1 2
2 3
1 3

Sample Output 1

2.41


&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int n,m;

struct node{
	int v;
	double w;
	node(){ };
	node(int _v,double _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[10100];

bool vis[10100];
double dst[10100];

int x[10100],y[10100];
int pre[10100];
void add(int u,int v,double w){
	g[u].push_back(node(v,w));
	g[v].push_back(node(u,w));
}


void dij(int s){

	memset(vis,0,sizeof vis);
	for(int i=1;i&amp;lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&amp;lt;g[u].size();j++){
			
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(dst[v]&amp;gt;dst[u]+w){
				dst[v]=dst[u]+w;
				pre[v]=u;
			}
		}
		
		double mi=1e20;
		for(int j=1;j&amp;lt;=n;j++){
			if(!vis[j]&amp;amp;&amp;amp;mi&amp;gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	}

}


void dij2(int s,int uu,int vv){
	
	memset(vis,0,sizeof vis);
	for(int i=1;i&amp;lt;=n;i++){
		dst[i]=1e20;
	}
	
	int u = s;
	dst[u]=0;
	vis[u]=1;
	
	int nn=n;
	while(nn--){
		for(int j=0;j&amp;lt;g[u].size();j++){
			int v = g[u][j].v;
			double w = g[u][j].w;
	
			if(uu ==u &amp;amp;&amp;amp; vv==v || uu==v &amp;amp;&amp;amp; vv == u){
				continue;
			}
	
			dst[v] = min(dst[v],dst[u]+w);

	}
		double mi=1e20;
		for(int j=1;j&amp;lt;=n;j++){
			if(!vis[j]&amp;amp;&amp;amp;mi&amp;gt;dst[j]){
				mi = dst[j];
				u = j;	
			}
		}
		vis[u] = 1;	
	 
	}

}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;m;
	int u,v;
	double w;
	
	for(int i=1;i&amp;lt;=n;i++){
		cin &amp;gt;&amp;gt; x[i] &amp;gt;&amp;gt;y[i];
	}
	
	while (m--){
		cin &amp;gt;&amp;gt; u &amp;gt;&amp;gt; v;
		w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));
		add(u,v,w);
	}
	
	dij(1);

	
	double mi=1e20;
	for(int i=n;pre[i]!=0;i=pre[i]){
		dij2(1,i,pre[i]);
		mi=min(mi,dst[n]);
	}
	     if(mi == 1e20){
	      cout &amp;lt;&amp;lt; &amp;quot;-1&amp;quot;&amp;lt;&amp;lt;endl;
		 }else{
			 cout&amp;lt;&amp;lt;fixed&amp;lt;&amp;lt;setprecision(2)&amp;lt;&amp;lt;mi&amp;lt;&amp;lt;endl;
		}
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;2p1359-租用游艇&#34;&gt;2.P1359 租用游艇&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
题目描述

长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&amp;lt;=i&amp;lt;=j&amp;lt;=n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。

对于给定的游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&amp;lt;=i&amp;lt;j&amp;lt;=n，编程计算从游艇出租站1 到游艇出租站n所需的最少租金。

保证计算过程中任何时刻数值都不超过10^6
输入输出格式
输入格式：

由文件提供输入数据。文件的第1 行中有1 个正整数n（n&amp;lt;=200），表示有n个游艇出租站。接下来的n-1 行是一个半矩阵r(i,j),1&amp;lt;=i&amp;lt;j&amp;lt;=n。

输出格式：

程序运行结束时，将计算出的从游艇出租站1 到游艇出租站n所需的最少租金输出到文件中。

输入输出样例
输入样例#1： 

3
5 15
7

输出样例#1： 

12


&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

using namespace std;
int maxn=0x3f3f3f3f; 
int vis[100001];
int dist[10001];
int a[1001][1001];
int main(){
   int n,j,k,l,i;
     cin&amp;gt;&amp;gt;n;
   for(j=0;j&amp;lt;=n;j++){
     for(k=0;k&amp;lt;=n;k++){
        a[j][k]=maxn;
        if(j==k)
            a[j][k]=0;
     }
     dist[j]=maxn;
   }
 
   for(j=1;j&amp;lt;=n;j++){
      for(k=j+1;k&amp;lt;=n;k++){
         cin&amp;gt;&amp;gt;a[j][k];
      }
   }
 
   for(j=1;j&amp;lt;=n;j++){
      dist[j]=a[1][j];
   }
   memset(vis,0,sizeof vis);
   vis[1]=1;
   for(j=1;j&amp;lt;=n;j++){
      int mi=maxn;
      for(i=1;i&amp;lt;=n;i++){
          if(!vis[i]&amp;amp;&amp;amp;dist[i]&amp;lt;mi){
              mi=dist[i];
              k=i;
          }
      }
      vis[k]=1;
 
      for(i=1;i&amp;lt;=n;i++){
          if(!vis[i]&amp;amp;&amp;amp;a[k][i]+dist[k]&amp;lt;dist[i]){
              dist[i]=dist[k]+a[k][i];
          }
      }
  
   }
   cout&amp;lt;&amp;lt;dist[n]&amp;lt;&amp;lt;endl;
 
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;3p3371-模板单源最短路径弱化版&#34;&gt;3.P3371 【模板】单源最短路径（弱化版）&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/weixin_43913349/article/details/89278981&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;4p1339-usaco09oct热浪heat-wave&#34;&gt;4.P1339 [USACO09OCT]热浪Heat Wave&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;
题目描述

The good folks in Texas are having a heatwave this summer. Their Texas Longhorn cows make for good eating but are not so adept at creating creamy delicious dairy products. Farmer John is leading the charge to deliver plenty of ice cold nutritious milk to Texas so the Texans will not suffer the heat too much.

FJ has studied the routes that can be used to move milk from Wisconsin to Texas. These routes have a total of T (1 &amp;lt;= T &amp;lt;= 2,500) towns conveniently numbered 1..T along the way (including the starting and ending towns). Each town (except the source and destination towns) is connected to at least two other towns by bidirectional roads that have some cost of traversal (owing to gasoline consumption, tolls, etc.). Consider this map of seven towns; town 5 is the

source of the milk and town 4 is its destination (bracketed integers represent costs to traverse the route):


                              [1]----1---[3]-
                             /               \
                      [3]---6---[4]---3--[3]--4
                     /               /       /|
                    5         --[3]--  --[2]- |
                     \       /        /       |
                      [5]---7---[2]--2---[3]---
                            |       /
                           [1]------

Traversing 5-6-3-4 requires spending 3 (5-&amp;gt;6) + 4 (6-&amp;gt;3) + 3 (3-&amp;gt;4) = 10 total expenses.

Given a map of all the C (1 &amp;lt;= C &amp;lt;= 6,200) connections (described as two endpoints R1i and R2i (1 &amp;lt;= R1i &amp;lt;= T; 1 &amp;lt;= R2i &amp;lt;= T) and costs (1 &amp;lt;= Ci &amp;lt;= 1,000), find the smallest total expense to traverse from the starting town Ts (1 &amp;lt;= Ts &amp;lt;= T) to the destination town Te (1 &amp;lt;= Te &amp;lt;= T).

德克萨斯纯朴的民眾们这个夏天正在遭受巨大的热浪！！！他们的德克萨斯长角牛吃起来不错，可是他们并不是很擅长生產富含奶油的乳製品。Farmer John此时以先天下之忧而忧，后天下之乐而乐的精神，身先士卒地承担起向德克萨斯运送大量的营养冰凉的牛奶的重任，以减轻德克萨斯人忍受酷暑的痛苦。

FJ已经研究过可以把牛奶从威斯康星运送到德克萨斯州的路线。这些路线包括起始点和终点先一共经过T (1 &amp;lt;= T &amp;lt;= 2,500)个城镇，方便地标号為1到T。除了起点和终点外地每个城镇由两条双向道路连向至少两个其它地城镇。每条道路有一个通过费用（包括油费，过路费等等）。

给定一个地图，包含C (1 &amp;lt;= C &amp;lt;= 6,200)条直接连接2个城镇的道路。每条道路由道路的起点Rs，终点Re (1 &amp;lt;= Rs &amp;lt;= T; 1 &amp;lt;= Re &amp;lt;= T)，和花费(1 &amp;lt;= Ci &amp;lt;= 1,000)组成。求从起始的城镇Ts (1 &amp;lt;= Ts &amp;lt;= T)到终点的城镇Te(1 &amp;lt;= Te &amp;lt;= T)最小的总费用。
输入输出格式
输入格式：

第一行: 4个由空格隔开的整数: T, C, Ts, Te

第2到第C+1行: 第i+1行描述第i条道路。有3个由空格隔开的整数: Rs, Re和Ci

输出格式：

一个单独的整数表示从Ts到Te的最小总费用。数据保证至少存在一条道路。

输入输出样例
输入样例#1： 复制

7 11 5 4
2 4 2
1 4 3
7 2 2
3 4 3
5 7 5
7 3 3
6 1 1
6 3 4
2 4 3
5 6 3
7 2 1

输出样例#1： 复制

7

说明

【样例说明】

5-&amp;gt;6-&amp;gt;1-&amp;gt;4 (3 + 1 + 3)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int inf=10100;
queue&amp;lt;int&amp;gt; qu;
int dst[inf];
bool inq[inf];
struct node{
    int t,dist;
};
vector&amp;lt;node&amp;gt; g[inf];
bool spfa(int s){
    memset(dst,0x7f,sizeof(dst));
    memset(inq,0,sizeof(inq));
    dst[s]=0;
    qu.push(s);
    inq[s]=true;
    while(!qu.empty()){
        int u=qu.front();
        qu.pop();
        inq[u]=0;
        for(int i=0;i&amp;lt;g[u].size();i++){
            int v=g[u][i].t;
            int w=g[u][i].dist;
            if(dst[u]+w&amp;lt;dst[v]){
                dst[v]=dst[u]+w;
                if(!inq[v])
                {
                    qu.push(v);
                    inq[v]=1;
                }
            }
        }
    }
}
int main()
{
    int n,m,st,en;
    cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;m&amp;gt;&amp;gt;st&amp;gt;&amp;gt;en;
    for(int i=0;i&amp;lt;m;i++){
        int x,y,v;
        cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y&amp;gt;&amp;gt;v;
        g[x].push_back((node){y,v});
        g[y].push_back((node){x,v});
    }
    spfa(st);
    cout&amp;lt;&amp;lt;dst[en];
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;可能你已经发现没有一个用的Floyd，只是因为太蒟了。&lt;/s&gt;&lt;/p&gt;
&lt;h2 id=&#34;欧拉回路&#34;&gt;欧拉回路&lt;/h2&gt;
&lt;p&gt;若图中存在这样一条路径，使得它恰好通过图中每条边一次，则称该路径为 欧拉路径。若该路径&lt;br&gt;
是一个环路，则称为 欧拉（Euler）回路。&lt;/p&gt;
&lt;p&gt;1.无向图有欧拉回路的条件&lt;br&gt;
一个无向图存在欧拉回路，当且仅当该图所有顶点度数都为偶数,且该图是连通图。&lt;br&gt;
2.有向图有欧拉回路的条件&lt;br&gt;
一个有向图存在欧拉回路，所有顶点的入度等于出度且该图是连通图。&lt;/p&gt;
&lt;p&gt;然后，其实也挺简单的。&lt;/p&gt;
&lt;p&gt;一道模板题：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目背景

Farmer John每年有很多栅栏要修理。他总是骑着马穿过每一个栅栏并修复它破损的地方。
题目描述

John是一个与其他农民一样懒的人。他讨厌骑马，因此从来不两次经过一个栅栏。你必须编一个程序，读入栅栏网络的描述，并计算出一条修栅栏的路径，使每个栅栏都恰好被经过一次。John能从任何一个顶点(即两个栅栏的交点)开始骑马，在任意一个顶点结束。

每一个栅栏连接两个顶点，顶点用1到500标号(虽然有的农场并没有500个顶点)。一个顶点上可连接任意多(&amp;gt;=1)个栅栏。两顶点间可能有多个栅栏。所有栅栏都是连通的(也就是你可以从任意一个栅栏到达另外的所有栅栏)。

你的程序必须输出骑马的路径(用路上依次经过的顶点号码表示)。我们如果把输出的路径看成是一个500进制的数，那么当存在多组解的情况下，输出500进制表示法中最小的一个 (也就是输出第一位较小的，如果还有多组解，输出第二位较小的，等等)。

输入数据保证至少有一个解。
输入输出格式
输入格式：

第1行: 一个整数F(1 &amp;lt;= F &amp;lt;= 1024)，表示栅栏的数目

第2到F+1行: 每行两个整数i, j(1 &amp;lt;= i,j &amp;lt;= 500)表示这条栅栏连接i与j号顶点。

输出格式：

输出应当有F+1行，每行一个整数，依次表示路径经过的顶点号。注意数据可能有多组解，但是只有上面题目要求的那一组解是认为正确的。

输入输出样例
输入样例#1： 复制

9
1 2
2 3
3 4
4 2
4 5
2 5
5 6
5 7
4 6

输出样例#1： 复制

1
2
3
4
2
5
4
6
5
7


&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn = 1010;
int n;
int eul[maxn][maxn],lu[maxn];
int sum=0;

stack&amp;lt;int&amp;gt; sta;


void dfs(int s){
    for(int i=1;i&amp;lt;=500;i++){
        if(eul[s][i]){
        eul[i][s]--;
        eul[s][i]--;
        
        dfs(i);	
        }
    }
    sta.push(s);
}


int main(){
    
    cin &amp;gt;&amp;gt; n;
    for(int i=1;i&amp;lt;=n;i++){
    	int x;
    	int y;
    	cin&amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
    	eul[x][y]++;
    	eul[y][x]++;
    	lu[x]++;
    	lu[y]++;
    }
    int num=1;
    for(int i=1;i&amp;lt;=500;i++){
        if(lu[i]%2){
            num=i;
            break;
        }
    }
    dfs(num);
    while(!sta.empty()){
    	cout &amp;lt;&amp;lt; sta.top()&amp;lt;&amp;lt;endl;
    	sta.pop();
    }
    	
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
">最短路算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/dfspai-dui-jian-ge-pai-lie/"" data-c="
          &lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;小Q是班长。在校运动会上，小Q班要进行队列表演。小Q要选出2*N名同学编队，每人都被编上一个号，每一个从1到N的自然数都被某2名同学佩戴，现在要求将他们排成一列，使两个编号为1的同学中间恰好夹1名同学，两个编号为2的同学中间恰好夹2名同学，……，两个编号为N的同学中间恰好夹N名同学，小Q希望知道这样的排法能否实现。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;input&#34;&gt;Input&lt;/h2&gt;
&lt;p&gt;输入文件仅包括一行，即要处理的N。N&amp;lt;=13&lt;/p&gt;
&lt;h2 id=&#34;output&#34;&gt;Output&lt;/h2&gt;
&lt;p&gt;输出有多少种排列顺序.&lt;/p&gt;
&lt;h2 id=&#34;sample-input&#34;&gt;Sample Input&lt;/h2&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;h2 id=&#34;sample-output&#34;&gt;Sample Output&lt;/h2&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;先理解一下题目，题目中所述，每一个从1到N的自然数都被某2名同学佩戴，说明共有2N名同学，两个编号为N的同学中间恰好夹N名同学，就可以得到一个排列（以n==3为例）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://img-blog.csdnimg.cn/20190714092334172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后，就可以用DFS搜索了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int n,ans=0;
int flag[100]={0};

void dfs(int dep){
	
	if(dep&amp;gt;n){
		ans++;
		return ;
	}
	for(int i=1;i&amp;lt;=2*n-dep-1;i++){
		if(!flag[i]&amp;amp;&amp;amp;!flag[i+dep+1]){//考虑当前位置有无其他数，和它的间隔有没有其他数
			flag[i]=flag[i+dep+1]=1;
			dfs(dep+1);
			flag[i]=flag[i+dep+1]=0;
		}
	}
}
int main(){
	cin &amp;gt;&amp;gt; n;
	dfs(1);
	cout &amp;lt;&amp;lt; ans;
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，可以发现，当程序运行12或13时，耗时很长，那么就可以想到剪枝优化。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;	if(n%4==1||n%4==2){
		return ; 
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，就可以证明一下这个剪枝的得到。&lt;br&gt;
设问题的一个解为a1+a2···+an,a1表示1。&lt;br&gt;
那么可以得到  a1+a2+…+an+(a1+1+1)+(a2+2+1)+…+(an+n+1) ，最后解得 4(a1+a2+…+an)=n(3n-1) ，所以n%4&lt;mark&gt;1或n%4&lt;/mark&gt;2无解。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int n,ans=0;
int flag[100]={0};

void dfs(int dep){
	
	if(n%4==1||n%4==2){
		return ; 
	}
	if(dep&amp;gt;n){
		ans++;
		return ;
	}
	for(int i=1;i&amp;lt;=2*n-dep-1;i++){
		if(!flag[i]&amp;amp;&amp;amp;!flag[i+dep+1]){
			flag[i]=flag[i+dep+1]=1;
			dfs(dep+1);
			flag[i]=flag[i+dep+1]=0;
		}
	}
}
int main(){
	cin &amp;gt;&amp;gt; n;
	dfs(1);
	cout &amp;lt;&amp;lt; ans;
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">[DFS]排队（间隔排列）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/2020-10-27-mo-ni-kao/"" data-c="
          &lt;p&gt;三道题目，有两道还是普及组T3和T4原题。。。&lt;br&gt;
&lt;s&gt;然鹅我似乎还是炸了呢&lt;/s&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;T1&lt;br&gt;
&lt;a href=&#34;https://www.luogu.com.cn/problem/P5661&#34;&gt;公交换乘&lt;/a&gt;&lt;br&gt;
著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：&lt;/p&gt;
&lt;p&gt;在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：tbus−tsubway≤45&lt;br&gt;
搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。&lt;br&gt;
搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。&lt;br&gt;
现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?&lt;/p&gt;
&lt;p&gt;输入格式&lt;br&gt;
输入文件的第一行包含一个正整数 n，代表乘车记录的数量。&lt;/p&gt;
&lt;p&gt;接下来的 n 行，每行包含 3 个整数，相邻两数之间以一个空格分隔。第 i 行的第 1 个整数代表第 i条记录乘坐的交通工具，0 代表地铁，1 代表公交车；第 2 个整数代表第 i 条记录乘车的票价 price&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
；第三个整数代表第 i 条记录开始乘车的时间 t&lt;br&gt;
i&lt;br&gt;
​	&lt;br&gt;
（距 0 时刻的分钟数）。&lt;/p&gt;
&lt;p&gt;我们保证出行记录是按照开始乘车的时间顺序给出的，且不会有两次乘车记录出现在同一分钟。&lt;/p&gt;
&lt;p&gt;输出格式&lt;br&gt;
输出文件有一行，包含一个正整数，代表小轩出行的总花费。&lt;/p&gt;
&lt;p&gt;输入输出样例&lt;br&gt;
输入 #1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135
输出 #1
36
输入 #2
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 
输出 #2
32
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;乘坐地铁的价格可以直接加入ans，主要处理在公交车是否免费的判断上。&lt;br&gt;
因为队列的性质是先进先出，而题目恰好要求如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。所以可以模拟队列，其中用一个结构体来表示优惠票的改变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
struct node{
	int pr,time,use;
}q[110001];//免费票的价格上限，能用的时间，是否可用；
int n;
int op,pri,ti,ans;
int tail,head;//模拟队列
int main(){
	cin &amp;gt;&amp;gt; n;
	for(int i=0;i&amp;lt;n;i++){
		cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; pri &amp;gt;&amp;gt; ti;
		if(op==0){//如果是地铁的情况
			ans+=pri;//直接将价格加入ans
			q[tail].time = ti + 45;//时间范围
			q[tail++].pr = pri; //存入票价
		}else if(op == 1){//公交车
			while (head &amp;lt; tail &amp;amp;&amp;amp; q[head].time &amp;lt; ti) {
                head++;
            }//放弃超过时间限制的票
            bool flag = 0;//标记
            for(int j=head;j&amp;lt;tail;j++){
            	if(q[j].pr &amp;gt;= pri &amp;amp;&amp;amp; q[j].use == 0){//如果存在免费票大于公交车价格的票，且没有没用过
            		flag = 1;
            		q[j].use = 1;//标记为用过
            		break;
				}
			}	
		if(!flag){
			ans+=pri;//如果不行，就将价格直接加入ans
		}
		}
	}
	cout &amp;lt;&amp;lt; ans;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;T2&lt;br&gt;
&lt;a href=&#34;https://www.luogu.com.cn/problem/P5018&#34;&gt;对称二叉树&lt;/a&gt;&lt;br&gt;
&lt;s&gt;有一道做过好几遍的题&lt;/s&gt;&lt;br&gt;
当时在NOI考场上我一脸懵逼，现在想来······&lt;/p&gt;
&lt;p&gt;一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树：&lt;br&gt;
二叉树；&lt;br&gt;
将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。&lt;br&gt;
下图中节点内的数字为权值，节点外的 id 表示节点编号。&lt;/p&gt;
&lt;p&gt;现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数 最多。请输出这棵子树的节点数。&lt;/p&gt;
&lt;p&gt;注意：只有树根的树也是对称二叉树。本题中约定，以节点 TT 为子树根的一棵“子 树”指的是：节点TT 和它的全部后代节点构成的二叉树。&lt;/p&gt;
&lt;p&gt;输入格式&lt;br&gt;
第一行一个正整数 n，表示给定的树的节点的数目，规定节点编号 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;∼&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1∼n&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;∼&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，其中节点 11 是树根。&lt;/p&gt;
&lt;p&gt;第二行 n 个正整数，用一个空格分隔，第 i 个正整数 v_i 代表节点 i 的权值。&lt;/p&gt;
&lt;p&gt;接下来 n 行，每行两个正整数 l_i, r_i ，分别表示节点 ii 的左右孩子的编号。如果不存在左 / 右孩子，则以 -1−1 表示。两个数之间用一个空格隔开。&lt;br&gt;
输出格式&lt;br&gt;
输出文件共一行，包含一个整数，表示给定的树的最大对称二叉子树的节点数。&lt;br&gt;
输入输出样例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入 #1
2 
1 3 
2 -1 
-1 -1 
输出 #1
1
输入 #2
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8
输出 #2
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;DFS可以水过去。&lt;br&gt;
搜索思路比较好想，以每个节点为根节点，判断左子树的值是否等于右子树值，就能找到它们是否是对称二叉树。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

int n;
int l[1010000],r[1010010];//左子树，右子树
bool vis;int a[10100100];
int ans=1 ;
int dfs(int x,int y,int s)//正在访问的节点，s为当前节点。
{
	if(x==-1&amp;amp;&amp;amp;y==-1)return 0;//返回条件
	if(x==-1||y==-1&amp;amp;&amp;amp;x!=y){
		vis=1;
		return 0;	
	}//对称二叉树
	if(a[x]!=a[y]){
		vis=1;
		return 0;
	}//对称
	return  dfs(l[x],r[y],2) + dfs(r[x],l[y],2) + s;
}

int main(){
	scanf(&amp;quot;%d&amp;quot;,&amp;amp;n);
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&amp;quot;%d&amp;quot;,&amp;amp;a[i]);
	}
	for(int i=1;i&amp;lt;=n;i++){
		scanf(&amp;quot;%d%d&amp;quot;,&amp;amp;l[i],&amp;amp;r[i]);
	}
	for(int i=1;i&amp;lt;=n;i++){
		if(dfs(l[i],r[i],3)&amp;gt;ans&amp;amp;&amp;amp;vis==0){
			ans = dfs(l[i],r[i],3);
		}
		vis = 0;
	}
	cout &amp;lt;&amp;lt; ans;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;T3&lt;br&gt;
&lt;a href=&#34;http://forioi.com/p/6217&#34;&gt;photo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啊这。。状压DP？&lt;s&gt;（然鹅考场上并不会）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;有N个人，来自K个家族.他们排成一行准备照相，但是由于天生的排外性，每个人都希望和本家族的人站在一起,中间不要加入别的家族的人.问最少从队列中去掉多少个就可以达到这个目的.&lt;br&gt;
输入&lt;br&gt;
第一行给出N,K。N在[1,100]，K在[1,5] 第二行给出N个数，每个数为1到K中的某个数。&lt;br&gt;
输出&lt;br&gt;
最少从队列中去掉多少个就可以达到这个目的&lt;/p&gt;
&lt;p&gt;样例&lt;br&gt;
输入&lt;br&gt;
10 3&lt;br&gt;
2 1 2 2 1 1 3 1 3 3&lt;/p&gt;
&lt;p&gt;输出&lt;br&gt;
2&lt;/p&gt;
&lt;p&gt;DP求解可以保留最多的人数，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n-ans&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.66666em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;即为所求。&lt;br&gt;
所以就看那种方法最优，要么当前状态是一个新的家族，要么保持连通，当前这个人与上一个同属于一个家族。&lt;/p&gt;
&lt;p&gt;用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dp[i][j][k]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;三个量来表示第i个人，第j状态，前一个人是第K家族的保留人数。&lt;/p&gt;
&lt;p&gt;一为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;/msup&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;;&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j ^ (1 &amp;lt;&amp;lt; a[i] - 1)][+ 1);&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.138em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8879999999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.5782em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 当前出现的家族。&lt;br&gt;
二为与上一个家族的人相同，即&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;;&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j][a[i]] + 1);&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
 int ans = 0;
int n, k, a[101001];
int dp[200][1000][10];
int main() {
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;k;
    for(int i = 1; i &amp;lt;= n; i++){
    cin &amp;gt;&amp;gt; a[i];	
    }
     
    for(int i = 1; i &amp;lt;= n; i++) {
        memcpy(dp[i], dp[i - 1], sizeof dp[i - 1]);
                 
        for(int j = 0; j &amp;lt; (1 &amp;lt;&amp;lt; k); j++) {
            if(j &amp;amp; (1 &amp;lt;&amp;lt; a[i] - 1)) {
                dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j][a[i]] + 1);
                for(int l = 0; l &amp;lt;= k; l++){
                	dp[i][j][a[i]] = max(dp[i][j][a[i]], dp[i - 1][j ^ (1 &amp;lt;&amp;lt; a[i] - 1)][l] + 1);
            		}
				}     
        }
    }
    for(int j = 0; j &amp;lt; (1 &amp;lt;&amp;lt; k); j++)
        for(int l = 0; l &amp;lt;= k; l++) 
            ans = max(ans, dp[n][j][l]);
             
    cout &amp;lt;&amp;lt;  n - ans;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">2020-10-27 模拟考</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/chai-fen-yue-shu/"" data-c="
          &lt;h4 id=&#34;1差分约束系统system-of-difference-constraints&#34;&gt;1.差分约束系统（system of difference constraints）&lt;/h4&gt;
&lt;p&gt;如果一个系统由n个变量和m个约束条件组成，形成m个形如ai-aj≤k的不等式(i,j∈[1,n],k为常数),则称其为差分约束系统(system of difference constraints)。亦即，差分约束系统是求解关于一组变量的特殊不等式组的方法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;求解差分约束系统，可以转化成图论的单源最短路径（或最长路径）问题。&lt;br&gt;
——百度百科&lt;br&gt;
如下列的不等式组&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x1-x5≤-1
x2-x5≤1
x3-x1≤5
x4-x1≤4
x4-x3≤-1
x5-x3≤-3
x5-x4≤-3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;比如1式 x1-x5≤-1，其中一个未知数x1与x5的差小于等于-1，就相当于设两个未知数x，y差为某一常数，由这些不等式构成的不等式方程组为差分约束系统。&lt;/p&gt;
&lt;h4 id=&#34;2例题&#34;&gt;2.例题&lt;/h4&gt;
&lt;h6 id=&#34;小k的农场&#34;&gt;小K的农场&lt;/h6&gt;
&lt;p&gt;关于洛谷一道蓝题。&lt;br&gt;
&lt;a href=&#34;https://www.luogu.org/problemnew/show/P1993&#34;&gt;P1993 小K的农场&lt;/a&gt;&lt;br&gt;
但因为在另一篇题解中写过了，所以不多做阐述，解题看好差分约束条件就行了。&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/weixin_43913349/article/details/89280139&#34;&gt;小K的农场（差分约束）题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;然后是另外两道题&lt;/p&gt;
&lt;h6 id=&#34;蒜头君的银行卡&#34;&gt;蒜头君的银行卡&lt;/h6&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;虽然蒜头君并没有多少钱，但是蒜头君办了很多张银行卡，共有 n 张，以至于他自己都忘记了每张银行卡里有多少钱了。他只记得一些含糊的信息，这些信息主要以下列三种形式描述：&lt;/p&gt;
&lt;p&gt;银行卡 a 比银行卡 b 至少多 c 元。&lt;br&gt;
银行卡 a 比银行卡 b 至多多 c 元。&lt;br&gt;
银行卡 a 和银行卡 c 里的存款一样多。&lt;br&gt;
但是由于蒜头君的记忆有些差，他想知道是否存在一种情况，使得银行卡的存款情况和他记忆中的所有信息吻合。&lt;/p&gt;
&lt;p&gt;Input&lt;br&gt;
第一行输入两个整数 n 和 m，分别表示银行卡数目和蒜头君记忆中的信息的数目。(1≤n,m≤10000)&lt;/p&gt;
&lt;p&gt;接下来 m 行：&lt;/p&gt;
&lt;p&gt;如果每行第一个数是 1，接下来有三个整数 a,b,c，表示银行卡 a 比银行卡 b 至少多 c元。&lt;/p&gt;
&lt;p&gt;如果每行第一个数是 2，接下来有三个整数 a,b,c，表示银行卡 a 比银行卡 b 至多多 c元。&lt;/p&gt;
&lt;p&gt;如果每行第一个数是 3，接下来有两个整数 a,b，表示银行卡 a 和 b 里的存款一样多。(1≤n,m,a,b,c≤10000)&lt;/p&gt;
&lt;p&gt;Output&lt;br&gt;
如果存在某种情况与蒜头君的记忆吻合，输出Yes，否则输出No。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;3 3&lt;br&gt;
3 1 2&lt;br&gt;
1 1 3 1&lt;br&gt;
2 2 3 2&lt;br&gt;
Sample Output 1&lt;/p&gt;
&lt;p&gt;Yes&lt;/p&gt;
&lt;p&gt;很明显，题目中出现了几个约束条件：&lt;br&gt;
银行卡 a 比银行卡 b 至少多 c 元。&lt;br&gt;
银行卡 a 比银行卡 b 至多多 c 元。&lt;br&gt;
银行卡 a 和银行卡 c 里的存款一样多。&lt;/p&gt;
&lt;p&gt;转化为不等式方程组：&lt;/p&gt;
&lt;p&gt;a-b&amp;gt;=c&lt;br&gt;
a-b&amp;lt;=c&lt;br&gt;
a=c&lt;/p&gt;
&lt;p&gt;找到了解题的关键，然后将差分约束转化为最短路求解 。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=10100;
const int inf=0x3f3f3f3f;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[maxn];
int dst[maxn];
queue &amp;lt;int&amp;gt; qu;
bool inq[maxn];
int cnt[maxn];


int add(int u,int v,int w){
	g[u].push_back(node(v,w));
//	g[v].push_back(node());
}

int spfa(int u){
	memset(inq,0,sizeof inq);
	memset(dst,inf,sizeof dst);
	memset(cnt,0,sizeof cnt);
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	cnt[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&amp;lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&amp;gt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
					cnt[v]++;
					if(cnt[v]&amp;gt;n+1){
					return 0;	
					}
				}
			}
		}
	}
	return 1;
}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	
	for(int i=0;i&amp;lt;m;i++){
		int d,a,b,c;
		cin &amp;gt;&amp;gt; d;
		if(d==1){
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
			g[a].push_back(node(b,-c));
		}else if(d==2){
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
			g[b].push_back(node(a,-c));
		}else{
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
			g[a].push_back(node(b,0));
			g[b].push_back(node(a,0));
		}
	}
	
	for(int i=1;i&amp;lt;=n;i++){
		add(0,i,0);
	}
	if(spfa(0)){
	cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot;&amp;lt;&amp;lt;endl;
}else{
	cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot;;
}
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h6 id=&#34;蒜头君当大厨&#34;&gt;蒜头君当大厨&lt;/h6&gt;
&lt;pre&gt;&lt;code&gt;Description

蒜头君苦练厨艺，终于成为了某高档酒店的大厨。

每天上班，蒜头君会被要求做 n 份菜。既然是高档酒店，那么客人们当然是很讲究的，尤其对于上菜的时间有很多要求。客人们的要求被分成下列四种：

菜品 a 的上菜时间必须比菜品 b 的上菜时间早 d 分钟或者更早。

菜品 a 的上菜时间必须比菜品 b 的上菜时间迟 d 分钟或者更迟。

菜品 a 的上菜时间在 d 分钟以后(包含 d 分钟)。

菜品 a 的上菜时间在 d 分钟之前(包含 d 分钟)。

蒜头君的上班时间记为 0 分钟。为了节约时间，在满足客人们要求的情况下，蒜头君希望最后上的一道菜的时间尽可能的早。（每道菜的上菜时间必须不早于蒜头君的上班时间）


Input
第一行输入一个整数 n，表示一共需要上 n 道菜。

第二行输入一个整数 m，表示客人们的要求数量。

接下里 m 行，每行先输入一个整数 op。

如果 op=1，表示描述里的第 1 种要求，后面跟着三个整数 a,b,d。
如果 op=2，表示描述里的第 2 种要求，后面跟着三个整数 a,b,d。
如果 op=3，表示描述里的第 3 种要求，后面跟着两个整数 a,d。
如果 op=4，表示描述里的第 4 种要求，后面跟着两个整数 a,d。

Output
如果蒜头君能满足客人们的要求，输出最后一道菜的上菜时间；否则输出一行 &#39;I can&#39;t&#39;。

数据范围和约定

对于所有的数据：1≤n,m≤20000，1≤∣d∣≤10000 ,1≤a,b≤n，a≠b。

样例解释 1

1,2,3 的上菜时间分别为 0,2,12，这样能满足输入客人们的所有要求，并且时间最短。



Sample Input 1 

3
5
2 3 2 10
2 2 1 2
2 3 2 5
1 2 3 7
3 3 9
Sample Output 1

12
Sample Input 2 

3
4
3 1 3
2 3 1 9
2 1 3 -1
1 1 2 5
Sample Output 2

I can&#39;t
Sample Input 3 

17
20
2 6 3 -21
1 8 2 54
3 7 -95
4 11 44
1 5 15 40
3 9 1
3 3 30
3 8 23
2 9 12 -15
4 13 61
2 3 7 31
1 5 10 -15
2 16 1 43
2 12 3 -79
2 14 16 -51
3 6 48
4 7 0
2 10 11 -59
2 12 17 -29
3 4 10
Sample Output 3

77
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与蒜头君的银行卡差不多，都是找到差分约束条件：&lt;br&gt;
菜品 a 的上菜时间必须比菜品 b 的上菜时间早 d 分钟或者更早。&lt;/p&gt;
&lt;p&gt;菜品 a 的上菜时间必须比菜品 b 的上菜时间迟 d 分钟或者更迟。&lt;/p&gt;
&lt;p&gt;菜品 a 的上菜时间在 d 分钟以后(包含 d 分钟)。&lt;/p&gt;
&lt;p&gt;菜品 a 的上菜时间在 d 分钟之前(包含 d 分钟)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=20010;

int n,m;

struct node{
	int v,w;
	node(){ }
	node(int _v,int _w){
		v=_v;
		w=_w;
	}
};

vector &amp;lt;node&amp;gt; g[maxn];
int dst[maxn];
queue &amp;lt;int&amp;gt; qu;
bool inq[maxn];
int cnt[maxn];
int flag;

int add(int u,int v,int w){
	g[u].push_back(node(v,w));
//	g[v].push_back(node());
}

void spfa(int u){
	memset(inq,0,sizeof inq);
	memset(dst,0x80,sizeof dst);
	memset(cnt,0,sizeof cnt);
	dst[u]=0;
	qu.push(u);
	inq[u]=1;
	cnt[u]=1;
	while(!qu.empty()){
		u=qu.front();
		qu.pop();
		inq[u]=0;
		for(int i=0;i&amp;lt;g[u].size();i++){
			int v=g[u][i].v;
			int w=g[u][i].w;
			if(dst[v]&amp;lt;dst[u]+w){
				dst[v]=dst[u]+w;
				if(!inq[v]){
					qu.push(v);
					inq[v]=1;
					cnt[v]++;
					if(cnt[v]&amp;gt;n+1){
						return;
					}
					if(cnt[v]==n+1){
						flag=1;
					}
				}
			}
		}
	}
	return;
}


int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	
	for(int i=0;i&amp;lt;m;i++){
		int d,a,b,c;
		cin &amp;gt;&amp;gt; d;
		if(d==1){
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
			g[a].push_back(node(b,c));
		}else if(d==2){
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c;
			g[b].push_back(node(a,c));
		}else if(d==3){
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
			g[0].push_back(node(a,b));
		}else{
			cin &amp;gt;&amp;gt;a&amp;gt;&amp;gt;b;
			g[0].push_back(node(0,-b));
		}
	}
	
	for(int i=1;i&amp;lt;=n;i++){
		add(0,i,0);
	}
int ans=0;
spfa(0);

if(flag){
	cout&amp;lt;&amp;lt;&amp;quot;I can&#39;t&amp;quot;;
	return 0;
}
 
 for(int i=1;i&amp;lt;=n;i++){
 ans=max(ans,dst[i]);
}
cout &amp;lt;&amp;lt; ans;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">差分约束</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/noip2010ji-qi-fan-yi-c/"" data-c="
          &lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;
&lt;p&gt;小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。这个翻译软件的原理很简单，它只是&lt;br&gt;
从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的&lt;br&gt;
中文含义&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词&lt;br&gt;
的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有 M 个单元，每单元&lt;br&gt;
能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M?1，软件会&lt;br&gt;
将新单词存入一个未使用的内存单元；若内存中已存入 M 个单词，软件会清空最早进入内存的那个单词，腾出单&lt;br&gt;
元来，存放新单词。假设一篇英语文章的长度为 N个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词&lt;br&gt;
典？假设在翻译开始前，内存中没有任何单词。&lt;/p&gt;
&lt;h2 id=&#34;input&#34;&gt;Input&lt;/h2&gt;
&lt;p&gt;输入文件共 2 行。每行中两个数之间用一个空格隔开。&lt;br&gt;
第一行为两个正整数 M和 N，代表内存容量和文章的长度。&lt;br&gt;
第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文 单词。文章中两个单词是&lt;br&gt;
同一个单词，当且仅当它们对应的非负整数相同。&lt;br&gt;
0&amp;lt;M≤100，0&amp;lt;N≤1000&lt;/p&gt;
&lt;h2 id=&#34;output&#34;&gt;Output&lt;/h2&gt;
&lt;p&gt;包含一个整数，为软件需要查词典的次数。&lt;/p&gt;
&lt;h2 id=&#34;sample-input&#34;&gt;Sample Input&lt;/h2&gt;
&lt;p&gt;3 7&lt;br&gt;
1 2 1 5 4 4 1&lt;/p&gt;
&lt;h2 id=&#34;sample-output&#34;&gt;Sample Output&lt;/h2&gt;
&lt;p&gt;5&lt;br&gt;
//整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：&lt;br&gt;
空：内存初始状态为空。&lt;br&gt;
1． 1：查找单词1 并调入内存。&lt;br&gt;
2． 1 2：查找单词 2 并调入内存。&lt;br&gt;
3． 1 2：在内存中找到单词 1。&lt;br&gt;
4． 1 2 5：查找单词 5 并调入内存。&lt;br&gt;
5． 2 5 4：查找单词 4 并调入内存替代单词 1。&lt;br&gt;
6． 2 5 4：在内存中找到单词 4。&lt;br&gt;
7． 5 4 1：查找单词 1 并调入内存替代单词 2。&lt;br&gt;
共计查了 5次词典。&lt;/p&gt;
&lt;p&gt;其实就是队列的操作，找到一个新单词，就将它存入队列不断更新。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int a[10000];
int main(){
    queue&amp;lt;int&amp;gt; q;
    int m,n,ans=0;
    int b;
    cin  &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
    for(int i=1;i&amp;lt;=n;i++){
        cin &amp;gt;&amp;gt; b;
        if(!a[b]){
            ans++;
            if(q.size()&amp;lt;m){
                a[b]=1;
                q.push(b);
            }else if(m!=0){
                a[q.front()]=0;
                a[b]=1;
                q.pop();
                q.push(b);
            }
        }
         
    }
    cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">[Noip2010]机器翻译-C++</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/zhan/"" data-c="
          &lt;hr&gt;
&lt;p&gt;一个，跟队列同样基础的数据结构。。。&lt;br&gt;
栈就是一种有限制的线性表，限制在于它只能先进后出。栈顶的第一个元素是栈顶元素，相反的是栈底。相当于吃薯片时，将薯片装入桶中为进栈，拿出来为出栈。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;###STL库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;stack&amp;lt;T&amp;gt;//T为一种变量类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;###stack操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push()-入栈
pop()-出栈
clear()-清空栈
top()-取栈顶元素
size()-栈的大小
empty()-清空栈
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;图论中的欧拉回路就有一定栈的使用。&lt;br&gt;
&lt;a href=&#34;https://www.luogu.org/problem/P2731&#34;&gt;P2731 骑马修栅栏 Riding the Fences&lt;br&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
const int maxn = 1010;
int n;
int eul[maxn][maxn],lu[maxn];
int sum=0;

stack&amp;lt;int&amp;gt; sta;//开一个栈

void dfs(int s){
    for(int i=1;i&amp;lt;=500;i++){
        if(eul[s][i]){
        eul[i][s]--;
        eul[s][i]--;
        
        dfs(i);	
        }
    }
    sta.push(s);//将元素s入栈
}


int main(){
    cin &amp;gt;&amp;gt; n;
    for(int i=1;i&amp;lt;=n;i++){
    	int x;
    	int y;
    	cin&amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
    	eul[x][y]++;
    	eul[y][x]++;
    	lu[x]++;
    	lu[y]++;
    }
    int num=1;
    for(int i=1;i&amp;lt;=500;i++){
        if(lu[i]%2){
            num=i;
            break;
        }
    }
    dfs(num);
    while(!sta.empty()){//栈是否为空
    	cout &amp;lt;&amp;lt; sta.top()&amp;lt;&amp;lt;endl;//输出栈顶元素
    	sta.pop();//出栈
    }
    	
    return 0;
} 
&lt;/code&gt;&lt;/pre&gt;
">栈</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/bing-cha-ji-disjoint-set-union/"" data-c="
          &lt;hr&gt;
&lt;h3 id=&#34;1并查集&#34;&gt;1.并查集&lt;/h3&gt;
&lt;p&gt;在一些有N个元素的集合问题中，我们通常是在开始让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。然而可以知道，这样空间时间复杂度极高，无法通过题目的时限，这个时候，就可以用到并查集来解答。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190518155257812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2初始化&#34;&gt;2.初始化&lt;/h3&gt;
&lt;p&gt;初始化很简单，将每个点所在集合初始化为它自己。如有n个点，就将数组fa[i]=i&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void init(){
	for(int i=1;i&amp;lt;=n;i++){
		fa[i]=i;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3查找&#34;&gt;3.查找&lt;/h3&gt;
&lt;p&gt;这一步，我们只需要找到根节点，即元素所在的集合。就是当fa[x]等于x时，就找到了根节点，return x。反之，继续查找。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int get(int x){
	if(fa[x]==x) return x;
	return get(fa[x]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4合并&#34;&gt;4.合并&lt;/h3&gt;
&lt;p&gt;将两个不同元素所在的集合合并为一个集合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void merge(int x,int y){
	fa[get(x)] = get(y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，让我们来看看模板的实现&lt;/p&gt;
&lt;h3 id=&#34;5思路例题&#34;&gt;5.思路&amp;amp;例题&lt;/h3&gt;
&lt;h4 id=&#34;p1551-亲戚&#34;&gt;P1551 亲戚&lt;/h4&gt;
&lt;p&gt;题目背景&lt;/p&gt;
&lt;p&gt;若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。&lt;br&gt;
题目描述&lt;/p&gt;
&lt;p&gt;规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。&lt;br&gt;
输入输出格式&lt;br&gt;
输入格式：&lt;/p&gt;
&lt;p&gt;第一行：三个整数n,m,p，（n&amp;lt;=5000,m&amp;lt;=5000,p&amp;lt;=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。&lt;/p&gt;
&lt;p&gt;以下m行：每行两个数Mi，Mj，1&amp;lt;=Mi，Mj&amp;lt;=N，表示Mi和Mj具有亲戚关系。&lt;/p&gt;
&lt;p&gt;接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。&lt;/p&gt;
&lt;p&gt;输出格式：&lt;/p&gt;
&lt;p&gt;P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。&lt;/p&gt;
&lt;p&gt;输入输出样例&lt;br&gt;
输入样例#1： 复制&lt;/p&gt;
&lt;p&gt;6 5 3&lt;br&gt;
1 2&lt;br&gt;
1 5&lt;br&gt;
3 4&lt;br&gt;
5 2&lt;br&gt;
1 3&lt;br&gt;
1 4&lt;br&gt;
2 3&lt;br&gt;
5 6&lt;/p&gt;
&lt;p&gt;输出样例#1： 复制&lt;/p&gt;
&lt;p&gt;Yes&lt;br&gt;
Yes&lt;br&gt;
No&lt;/p&gt;
&lt;p&gt;这道题就可以用并查集来实现。&lt;br&gt;
相当于&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190518162322855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图，x为y的亲戚，而y又为z的亲戚，所以z为x的亲戚。&lt;br&gt;
然后，就可以搞一波了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=10010;


int n,m,p;
int fa[maxn];

void init(){
	for(int i=1;i&amp;lt;=n;i++){
		fa[i]=i;
	}
}
int get(int x){
	if(fa[x]==x) return x;
	return get(fa[x]);
}

void merge(int x,int y){
	fa[get(x)] = get(y);
}
int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m&amp;gt;&amp;gt;p;
	init();
	int x,y;
	for(int i=1;i&amp;lt;=m;i++){
		cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
		merge(x,y);
	}
	for(int i=1;i&amp;lt;=p;i++){
		cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
	    if(get(x)==get(y))cout &amp;lt;&amp;lt; &amp;quot;Yes&amp;quot;&amp;lt;&amp;lt;endl;
		else cout &amp;lt;&amp;lt; &amp;quot;No&amp;quot; &amp;lt;&amp;lt;endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是，不妨想想，这样做会不会太麻烦？&lt;br&gt;
如果z想要知道自己还有没有亲戚，那他就必须问y，才能找到x，这样，会不会耗时间。&lt;br&gt;
再想想，如果有很多亲戚，找起来会不会太慢？&lt;br&gt;
所以，现在看看另一道题&lt;/p&gt;
&lt;h4 id=&#34;p3367-模板并查集&#34;&gt;P3367 【模板】并查集&lt;/h4&gt;
&lt;p&gt;题目描述&lt;/p&gt;
&lt;p&gt;如题，现在有一个并查集，你需要完成合并和查询操作。&lt;br&gt;
输入输出格式&lt;br&gt;
输入格式：&lt;/p&gt;
&lt;p&gt;第一行包含两个整数N、M，表示共有N个元素和M个操作。&lt;/p&gt;
&lt;p&gt;接下来M行，每行包含三个整数Zi、Xi、Yi&lt;/p&gt;
&lt;p&gt;当Zi=1时，将Xi与Yi所在的集合合并&lt;/p&gt;
&lt;p&gt;当Zi=2时，输出Xi与Yi是否在同一集合内，是的话输出Y；否则话输出N&lt;/p&gt;
&lt;p&gt;输出格式：&lt;/p&gt;
&lt;p&gt;如上，对于每一个Zi=2的操作，都有一行输出，每行包含一个大写字母，为Y或者N&lt;/p&gt;
&lt;p&gt;输入输出样例&lt;br&gt;
输入样例#1：&lt;/p&gt;
&lt;p&gt;4 7&lt;br&gt;
2 1 2&lt;br&gt;
1 1 2&lt;br&gt;
2 1 2&lt;br&gt;
1 3 4&lt;br&gt;
2 1 4&lt;br&gt;
1 2 3&lt;br&gt;
2 1 4&lt;/p&gt;
&lt;p&gt;输出样例#1：&lt;/p&gt;
&lt;p&gt;N&lt;br&gt;
Y&lt;br&gt;
N&lt;br&gt;
Y&lt;/p&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;p&gt;时空限制：1000ms,128M&lt;/p&gt;
&lt;p&gt;数据规模：&lt;/p&gt;
&lt;p&gt;对于30%的数据，N&amp;lt;=10，M&amp;lt;=20；&lt;/p&gt;
&lt;p&gt;对于70%的数据，N&amp;lt;=100，M&amp;lt;=1000；&lt;/p&gt;
&lt;p&gt;对于100%的数据，N&amp;lt;=10000，M&amp;lt;=200000。&lt;/p&gt;
&lt;p&gt;这倒就要用到路径压缩。&lt;br&gt;
如何压缩？&lt;br&gt;
简单来说就是将原本的子孙节点全部直接连到根节点上。&lt;br&gt;
&lt;img src=&#34;https://img-blog.csdnimg.cn/20190531200520930.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxMzM0OQ==,size_16,color_FFFFFF,t_70&#34; alt=&#34;在这里插入图片描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
让它们直接找到x，就行了。&lt;br&gt;
所以，只需要改一改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=10010;


int n,m;
int fa[maxn];

void init(){
	for(int i=1;i&amp;lt;=n;i++){
		fa[i]=i;
	}
}
int get(int x){
	if(fa[x]==x) return x;
	return fa[x]=get(fa[x]);
}

void merge(int x,int y){
	fa[get(x)] = get(y);
}
int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
	init();
	int x,y,z;
	for(int i=1;i&amp;lt;=m;i++){
		cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt; z;
		if(x==1){
		merge(y,z);
	    }else if(get(y)==get(z))cout &amp;lt;&amp;lt; &amp;quot;Y&amp;quot;&amp;lt;&amp;lt;endl;
		else cout &amp;lt;&amp;lt; &amp;quot;N&amp;quot; &amp;lt;&amp;lt;endl;
	}

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;各种各样的并查集&#34;&gt;各种各样的并查集&lt;/h4&gt;
&lt;h5 id=&#34;网络交友&#34;&gt;网络交友&lt;/h5&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;在网络社交的过程中，通过朋友，也能认识新的朋友。在某个朋友关系图中，假定 A 和 B 是朋友，B 和 C 是朋友，那么 A 和 C 也会成为朋友。即，我们规定朋友的朋友也是朋友。&lt;/p&gt;
&lt;p&gt;现在要求你每当有一对新的朋友认识的时候，你需要计算两人的朋友圈合并以后的大小。&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;第一行：一个整数 n(n≤5000)n(n\leq 5000)n(n≤5000)，表示有 nnn 对朋友认识。&lt;/p&gt;
&lt;p&gt;接下来 nnn 行：每行输入两个名字。表示新认识的两人的名字，用空格隔开。（名字是一个首字母大写后面全是小写字母且长度不超过 20 的串）。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;对于每一对新认识的朋友，输出合并以后的朋友圈的大小。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;3&lt;br&gt;
Fred Barney&lt;br&gt;
Barney Betty&lt;br&gt;
Betty Wilma&lt;/p&gt;
&lt;p&gt;Sample Output 1&lt;/p&gt;
&lt;p&gt;2&lt;br&gt;
3&lt;br&gt;
4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=10010;
int n,k;
int sz[maxn],fa[maxn];

map&amp;lt;string, int&amp;gt;mp;

void init(){
	for(int i=1;i&amp;lt;=n+1;i++){
		fa[i]=i;
		sz[i]=1;
	}
}

int get(int x){
	if(fa[x]==x) return x;
	else return fa[x]=get(fa[x]);
}

void merge(int x,int y){
	int tx=get(x);
	int ty=get(y);
	if(tx!=ty){
		fa[tx]=ty;
        sz[ty]+=sz[tx];
	}
}

int main(){
	cin &amp;gt;&amp;gt; n;
	int ans=0;
	init();
	string s1,s2;
	while(n--){
		cin &amp;gt;&amp;gt; s1 &amp;gt;&amp;gt; s2;
		int x,y;
		if((x=mp[s1]) == 0) x = mp[s1] = ++k;
		if((y=mp[s2]) == 0) y = mp[s2] = ++k;
		merge(x,y);
		cout &amp;lt;&amp;lt; sz[get(y)] &amp;lt;&amp;lt; endl;
			}
	
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;昆虫的生活&#34;&gt;昆虫的生活&lt;/h5&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;一天蒜头君正在研究一种稀有昆虫的行为。他们具有两种不同的性别，他假设他们只与异性昆虫互动。因为他们背上都印有数字，所以他们之间的一起互动，在实验室是很容易识别的。&lt;/p&gt;
&lt;p&gt;现在给出一些昆虫之间的互动，看看实验是否支持蒜头君的假设--只有异性互动。&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;第一行输入两个整数 nnn (1≤n≤2000)(1 \le n \le 2000)(1≤n≤2000) ， mmm (1≤m≤106)(1 \le m \le 10^6)(1≤m≤106)。其中 nnn 表示昆虫的数目，mmm 表示昆虫互动的关系数量。&lt;/p&gt;
&lt;p&gt;接下来会有 mmm 行，每行有两个整数 xxx ， yyy (1≤x,y≤n)(1 \le x,y \le n)(1≤x,y≤n)。表示昆虫 xxx 和昆虫 yyy 之间有过互动。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;判断蒜头君的假设是否正确，如果正确请输入yes，否则输出no。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;3 3&lt;br&gt;
1 2&lt;br&gt;
2 3&lt;br&gt;
1 3&lt;/p&gt;
&lt;p&gt;Sample Output 1&lt;/p&gt;
&lt;p&gt;no&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn=5010;

struct node{
	int x,y;
}g[10000010];

int fa[maxn*2];
int n,m;
int init(){
	for(int i=1;i&amp;lt;=n*2;i++){
		fa[i]=i;
	}
}

int get(int x){
	if(fa[x]==x)return x;
	int r=get(fa[x]);
	fa[x]=r;
	return r;
}

void merge(int x,int y){
	fa[get(x)]=get(y);
}
int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt;m;
	init();
	for(int i=1;i&amp;lt;=m;i++){
		cin &amp;gt;&amp;gt; g[i].x  &amp;gt;&amp;gt; g[i].y;
	}
	for(int i=1;i&amp;lt;=m;i++){
		if(get(g[i].x)==get(g[i].y)) {
		cout &amp;lt;&amp;lt;&amp;quot;no&amp;quot;&amp;lt;&amp;lt;endl;
		return 0;
	}
		merge(g[i].x,g[i].y+n);
		merge(g[i].y,g[i].x+n);
	}
	cout &amp;lt;&amp;lt;&amp;quot;yes&amp;quot;;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;关押罪犯&#34;&gt;关押罪犯&lt;/h5&gt;
&lt;p&gt;Description&lt;/p&gt;
&lt;p&gt;S 城现有两座监狱，一共关押着 NNN 名罪犯，编号分别为 111 ~ NNN。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用 “怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 ccc 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 ccc 的冲突事件。&lt;/p&gt;
&lt;p&gt;每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。&lt;/p&gt;
&lt;p&gt;在详细考察了 NNN 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。&lt;/p&gt;
&lt;p&gt;那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？&lt;/p&gt;
&lt;p&gt;Input&lt;/p&gt;
&lt;p&gt;输入第一行为两个正整数 N(1≤N≤20000)和 M(1≤M≤100000)，分别表示罪犯的数目以及存在仇恨的罪犯对数。&lt;/p&gt;
&lt;p&gt;接下来的 M 行每行为三个正整数 aj,bj,a_j,b_j，表示 a_j​ 号和 b_j​ 号罪犯之间存在仇恨，其怨气值为 c_j​。数据保证 1&amp;lt;aj,bj≤N1&amp;lt;a_j, b_j \le N1&amp;lt;aj​,bj​≤N，0&amp;lt;cj≤1090 &amp;lt; c_j \le 10^90&amp;lt;cj​≤109，且每对罪犯组合只出现一次。&lt;/p&gt;
&lt;p&gt;Output&lt;/p&gt;
&lt;p&gt;输出共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 000。&lt;/p&gt;
&lt;p&gt;Sample Input 1&lt;/p&gt;
&lt;p&gt;4 6&lt;br&gt;
1 4 2534&lt;br&gt;
2 3 3512&lt;br&gt;
1 2 28351&lt;br&gt;
1 3 6618&lt;br&gt;
2 4 1805&lt;br&gt;
3 4 12884&lt;/p&gt;
&lt;p&gt;Sample Output 1&lt;/p&gt;
&lt;p&gt;3512&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int maxn = 200100;
const int maxm = 100100;
struct node{
	int u,v;
	int s;
}e[maxm];

bool cmp(node a,node b){
	return a.s&amp;gt;b.s;
}

int fa[maxn*2];
int n,m;
void init(){
	for(int i=1;i&amp;lt;=2*n;i++){
		fa[i] = i;
	}
}

int get(int x){
	if(fa[x]!=x) fa[x]=get(fa[x]);
	return fa[x];
}

void merge(int x,int y)
{
    fa[get(x)] = get(y);
}
int main(){
	cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
		init();
    	for(int i=1;i&amp;lt;=m;i++){
    		cin &amp;gt;&amp;gt; e[i].u &amp;gt;&amp;gt; e[i].v &amp;gt;&amp;gt; e[i].s;
		}
	sort(e+1,e+m+1,cmp);

for(int i=1;i&amp;lt;=m;i++){
	if(get(e[i].u)==get(e[i].v)){
	   
		cout &amp;lt;&amp;lt; e[i].s;
		return 0;
	}else{
		merge(e[i].u,e[i].v+n);
		merge(e[i].u+n,e[i].v);
		
    } 
}
	cout &amp;lt;&amp;lt; &amp;quot;0&amp;quot;;
	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;接龙&#34;&gt;接龙&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;http://120.77.248.79/problem/3033102&#34;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前缀差分思想，维护每个纸牌前面到底有多少纸牌的特性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

const int N=50100;
int n,m;
int fa[N];
int size[N],dist[N];

void init(){
    for(int i=0;i&amp;lt;N;i++){
        fa[i]=i;
        size[i]=1;
        dist[i]=0;
    }
}

int get(int x){
    if(fa[x]==x){
        return x;
    }
    int y=fa[x];
    fa[x]=get(y);
    dist[x]+=dist[y];
    return fa[x];
}

void merge(int x,int y){
    x=get(x);
    y=get(y);
    if(x!=y){
        fa[x]=y;
        dist[x]=size[y];
        size[y]+=size[x];
    }
}
int main(){
	
    init();
    int n;
    cin&amp;gt;&amp;gt;n;
    
    while(n--){
        char op;
        int x,y;
        cin&amp;gt;&amp;gt;op&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y;
        if(op==&#39;M&#39;){
            merge(x,y);
        }else{
            if(get(x)==get(y)){
                cout&amp;lt;&amp;lt;fabs(dist[x]-dist[y])-1&amp;lt;&amp;lt;endl;
            }else{
                cout&amp;lt;&amp;lt;&amp;quot;-1&amp;quot;&amp;lt;&amp;lt;endl;
            }
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">并查集（Disjoint Set Union）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/dan-diao-dui-lie/"" data-c="
          &lt;h4 id=&#34;单调队列的性质&#34;&gt;&lt;strong&gt;单调队列的性质&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;单调就是指一直增或一直减，例如1，2，3，4就是单调增，4，3，2，1就是单调减。而单调队列就有这种性质。&lt;br&gt;
所以，单调队列具有单调性以及队列的性质。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h4 id=&#34;操作方式&#34;&gt;&lt;strong&gt;操作方式&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;数据结构队列是先进先出，相当于数列3,7,5,9,现在有一个数2要进队，那么，按队列的操作应该将数列变为7,5,9,2。&lt;/p&gt;
&lt;p&gt;然而单调队列就不一样。假设有一条队列7,6,3,4，现在又有一个数5要进队，却看见3，4都比5要弱~~（类似MYJ在某STARLbast中将LYH打爆的行为）~~，所以就有了一种类似插队的方法，5将3和4挤掉，来到了6的后面，构成了这种队列：&lt;br&gt;
&lt;img src=&#34;https://i.loli.net/2019/08/12/QXpNaTmjAouB4sD.png&#34; alt=&#34;此处输入图片的描述&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;所以单调队列维护单调性就是通过插队把队尾破坏了单调的数全部从队尾退队，使队列元素维持单调（单调队列与队列不同就是单调队列既可以从队首出队，也可以从队尾出队）。&lt;br&gt;
看看一道模板&lt;s&gt;水&lt;/s&gt;题&lt;br&gt;
&lt;a href=&#34;https://www.luogu.org/problem/P1886&#34;&gt;P1886 滑动窗口&lt;/a&gt;&lt;br&gt;
&lt;s&gt;据说可以用线段树，树状数组什么的，但单调队列是拯救蒟蒻的做法(逃&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;所以说，这道题到底怎么做？&lt;br&gt;
其实只需要枚举所有的连续子序列，使用单调队列找出最大值。&lt;br&gt;
开始&lt;s&gt;乱搞&lt;/s&gt;写代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,k;
int a[1000001]={0},q[10000001]={0};q数组表示单调队列，a表示其所对应的在原列表里的下标
int head=1;//头指针
int tail=1;//队尾指针
int main(){
	cin &amp;gt;&amp;gt; n&amp;gt;&amp;gt;k;
	for(int i=1;i&amp;lt;=n;i++){
		cin&amp;gt;&amp;gt;a[i];
	}
	for(int i=1;i&amp;lt;=n;i++){
		while(head&amp;lt;tail&amp;amp;&amp;amp;a[q[tail-1]]&amp;gt;a[i]){
			tail--;//插队，将后面的数踢掉，以维护单调性
		}
		q[tail++]=i;//存编号
        while(head&amp;lt;tail&amp;amp;&amp;amp;q[head]&amp;lt;=i-k){
        	head++;//队首元素太old了，就出队。
		}
        if(i&amp;gt;=k){
        	cout &amp;lt;&amp;lt;a[q[head]]&amp;lt;&amp;lt; &amp;quot; &amp;quot;;//按题目要求的输出
		}
	}
	cout &amp;lt;&amp;lt; endl;
	--------------------------------------------------------------------------------------------
	head=1,tail=1;

	for(int i=1;i&amp;lt;=n;i++){
		while(head&amp;lt;tail&amp;amp;&amp;amp;a[q[tail-1]]&amp;lt;a[i]){//队列中存在元素，又队尾元素比下一个处理的值大，即表示队尾元素太old，就让队尾元素出队。当队尾元素小于下一个处理值，单调性成立。
			tail--;
		}
		q[tail++]=i;//存编号
        while(head&amp;lt;tail&amp;amp;&amp;amp;q[head]&amp;lt;=i-k){
        	head++;//队首元素太old了，就出队。
		}
        if(i&amp;gt;=k){
        	cout &amp;lt;&amp;lt; a[q[head]] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;//cout队首元素，即最大值
		}
	}
	cout &amp;lt;&amp;lt; endl;
	return 0;
	//实际上分割线上下代码都差不多，只是维护单调性的while循环不一样
}
&lt;/code&gt;&lt;/pre&gt;
">单调队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/youxian/"" data-c="
          &lt;hr&gt;
&lt;p&gt;优先队列，是，一个跟单调队列一样神奇的数据结构。&lt;br&gt;
手写优先队列不会，只能用STL库自带的priority_queue。&lt;/p&gt;
&lt;h2 id=&#34;声明priority_queue的头文件&#34;&gt;声明priority_queue的头文件&lt;/h2&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;queue&amp;gt;或#include&amp;lt;bits/stdc++.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,less&amp;lt;int&amp;gt;&amp;gt; a; //less&amp;lt;int&amp;gt;递增函数
priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt; &amp;gt;q;//depue双端队列，greater&amp;lt;int&amp;gt;递减函数
priority_queue&amp;lt;int&amp;gt;a;
priority_queue&amp;lt;double&amp;gt;a;
---------------------------------------------------
struct node{
~~~~~
}
priority_queue&amp;lt;node&amp;gt;a;
--------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;priority_queue的操作&#34;&gt;priority_queue的操作&lt;/h2&gt;
&lt;p&gt;实际上就是那些：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;priority_queue&amp;lt;int&amp;gt;q;
q.empty()——队列是否为空，空为true，否则为false
q.pop()——删除队顶元素
q.push()——压入一个元素
q.size()——返回优先队列中的元素个数
q.top()——返回q的第一个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;priority_queue的排序方式&#34;&gt;priority_queue的排序方式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;priority_queue&amp;lt;int&amp;gt; q;//优先队列自带排序，元素从大到小的顺序排序出队
priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;, greater&amp;lt;int&amp;gt; &amp;gt; q;//greater&amp;lt;int&amp;gt;，按照元素从小到大的顺序排序出队
struct cmp{
	int x,y;
	bool operator&amp;lt; (const node &amp;amp; a)const{
		return x&amp;lt;a.x;
	}
};//自定义结构体，重载&amp;lt;；

priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,less&amp;lt;int&amp;gt; &amp;gt; a;//less排序从大到小
priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;,greater&amp;lt;int&amp;gt; &amp;gt;a; //greater排序从小到大
//less和greater后的两个&amp;gt;之间要打&amp;quot; &amp;quot;，不然错哪里都不知道~~（绝对没有体验过）~~

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以，优先队列实际上就是一个自带从大到小排序的队列，最大元素会排在队首，然后，跟队列一样先进先出~~（感觉比单调队列半路插队要好写一些？）~~&lt;br&gt;
那就做一道例题吧~~（绝对没有滑动窗口的普及+/提高）~~&lt;br&gt;
&lt;a href=&#34;https://www.luogu.org/problem/P3887&#34;&gt;P3887 [GDOI2014]世界杯&lt;/a&gt;&lt;br&gt;
读题可知，这道题有四个综合水平值，说明了什么？&lt;br&gt;
当然是开四个优先队列啦~~（逃~~&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;

priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt; &amp;gt; k,d,m,f;//根据题目开的四个优先队列，也可以打四次priority_queue&amp;lt;int,vector&amp;lt;int&amp;gt;, less&amp;lt;int&amp;gt; &amp;gt;，不然考试背不到priority_queue就完了
int q;
int a,b,c,e;//守门员、后卫、中场和前锋供挑选的球员人数
int main(){
	int cnt;//存储
	cin &amp;gt;&amp;gt; a&amp;gt;&amp;gt;b&amp;gt;&amp;gt;c&amp;gt;&amp;gt;e;
	for(int i=1;i&amp;lt;=a;i++){
		cin &amp;gt;&amp;gt; cnt;
		f.push(cnt);
	}
	for(int i=1;i&amp;lt;=b;i++){
		cin &amp;gt;&amp;gt; cnt;
		m.push(cnt);
	}
	for(int i=1;i&amp;lt;=c;i++){
		cin &amp;gt;&amp;gt; cnt;
		d.push(cnt);
	}
	for(int i=1;i&amp;lt;=e;i++){
		cin &amp;gt;&amp;gt; cnt;
		k.push(cnt); 
	}//守门员、后卫、中场和前锋的能力值，分push进自己优先队列
	cin &amp;gt;&amp;gt;q;
	int x,y,z;
	
	for(int i=1;i&amp;lt;=q;i++){//对综合水平值的计算
		int ans=0;//ans放外面的值就不会清零了，所以放在for内
		cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y &amp;gt;&amp;gt;z;
		while(z--){
			int cnt=k.top();
			k.pop();
			ans+=cnt;
		}//出队，当前总能力值+上cnt 
		while(y--){
			int cnt=d.top();
			d.pop();
			ans+=cnt;
		}同上
		while(x--){
			int cnt=m.top();
			m.pop();
			ans+=cnt;
		}同上
		ans+=f.top();
		f.pop();题目所说不把守门员计算在内，单独处理
		printf(&amp;quot;%.2lf\n&amp;quot;,ans*1.0/11);//关于输出两位数的处理
	}
	

	return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">初涉优先队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;一个蒟蒻oier的小站&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;坐标CQ&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://ACLYH.github.io/post/hello-world/"" data-c="
          &lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int main(){
    cout &amp;lt;&amp;lt; &amp;quot;Hello world&amp;quot;&amp;lt;&amp;lt;endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;about-me&#34;&gt;About me&lt;/h2&gt;
&lt;p&gt;一个&lt;strong&gt;CQ&lt;/strong&gt;的蒟蒻OIer&lt;/p&gt;
">Hello world</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>




</html>